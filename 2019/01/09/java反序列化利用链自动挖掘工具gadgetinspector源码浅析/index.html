<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="自动化工具,gadgetinspector,java反序列化,">










<meta name="description" content="0x01 前言我们在使用ysoserial的时候，经常会用它生成序列化的payload，用于攻击具有反序列化功能的endpoint，而这些payload大部分都是比较长的一条执行链，在反序列化期间，由执行程序执行攻击者可控的source，然后通过依赖中存在的执行链，最终触发至slink，从而达到攻击的效果。 这些gadget chain有长有短，大部分可以通过类似Intellij idea这类工具">
<meta name="keywords" content="自动化工具,gadgetinspector,java反序列化">
<meta property="og:type" content="article">
<meta property="og:title" content="java反序列化利用链自动挖掘工具gadgetinspector源码浅析">
<meta property="og:url" content="http://yoursite.com/2019/01/09/java反序列化利用链自动挖掘工具gadgetinspector源码浅析/index.html">
<meta property="og:site_name" content="大彩笔threedr3am">
<meta property="og:description" content="0x01 前言我们在使用ysoserial的时候，经常会用它生成序列化的payload，用于攻击具有反序列化功能的endpoint，而这些payload大部分都是比较长的一条执行链，在反序列化期间，由执行程序执行攻击者可控的source，然后通过依赖中存在的执行链，最终触发至slink，从而达到攻击的效果。 这些gadget chain有长有短，大部分可以通过类似Intellij idea这类工具">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-01-09T02:35:27.956Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java反序列化利用链自动挖掘工具gadgetinspector源码浅析">
<meta name="twitter:description" content="0x01 前言我们在使用ysoserial的时候，经常会用它生成序列化的payload，用于攻击具有反序列化功能的endpoint，而这些payload大部分都是比较长的一条执行链，在反序列化期间，由执行程序执行攻击者可控的source，然后通过依赖中存在的执行链，最终触发至slink，从而达到攻击的效果。 这些gadget chain有长有短，大部分可以通过类似Intellij idea这类工具">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/09/java反序列化利用链自动挖掘工具gadgetinspector源码浅析/">





  <title>java反序列化利用链自动挖掘工具gadgetinspector源码浅析 | 大彩笔threedr3am</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8346bb07e7843cd10a2ee33017b3d627";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大彩笔threedr3am</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/09/java反序列化利用链自动挖掘工具gadgetinspector源码浅析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="threedr3am">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彩笔threedr3am">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java反序列化利用链自动挖掘工具gadgetinspector源码浅析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-09T10:32:41+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/安全开发/" itemprop="url" rel="index">
                    <span itemprop="name">安全开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>我们在使用ysoserial的时候，经常会用它生成序列化的payload，用于攻击具有反序列化功能的endpoint，而这些payload大部分都是比较长的一条执行链，在反序列化期间，由执行程序执行攻击者可控的source，然后通过依赖中存在的执行链，最终触发至slink，从而达到攻击的效果。</p>
<p>这些gadget chain有长有短，大部分可以通过类似Intellij idea这类工具去根据slink，查找调用者，以及各种调用者的实现，一路反向的跟踪，对于一些比较简单比较短的链，通常通过人工查找也能快速的找到，但是对于一些比较长的链，人工查找会耗费巨大的精力和时间，并且不一定能挖掘到gadget chain。</p>
<p>而有段时间，我苦恼于人工查找浪费巨大精力得不偿失时，忽然发现这样一款自动化挖掘gadget chain的工具，通过阅读分析它的源码，它给我带来了非常多的知识以及自动化挖掘的思路，其中就包括类似污点分析，如何去分析方法调用中，参数是否可以影响返回值，从而跟踪数据流动是否可以从source最终流动至slink，并影响至最终的slink点。</p>
<p><strong>gadgetinspector</strong>：</p>
<p><a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p>
<p><strong>slink</strong>：</p>
<ul>
<li>Runtime.exec()：这种利用最为简单，但是实际生产情况基本不会遇到</li>
<li>Method.invoke()：这种方式通过反射执行方法，需要方法以及参数可控</li>
<li>RMI/JRMP：通过反序列化使用RMI或者JRMP链接到我们的exp服务器，通过发送序列化payload至靶机实现</li>
<li>URL.openStream：这种利用方式需要参数可控，实现SSRF</li>
<li>Context.lookup：这种利用方式也是需要参数可控，最终通过rmi或ldap的server实现攻击</li>
<li>…等等</li>
</ul>
<p>在分析gadgetinspector源码的时候，大概会在以下几方面去讲解，并核心分析ASM部分，详细讲解如何进行污点分析：</p>
<ol>
<li>GadgetInspector：main方法，程序的入口，做一些配置以及数据的准备工作</li>
<li>MethodDiscovery：类、方法数据以及父子类、超类关系数据的搜索</li>
<li>PassthroughDiscovery：分析参数能影响到返回值的方法，并收集存储</li>
<li>CallGraphDiscovery：记录调用者caller方法和被调用者target方法的参数关联</li>
<li>SourceDiscovery：入口方法的搜索，只有具备某种特征的入口才会被标记收集</li>
<li>GadgetChainDiscovery：整合以上数据，并通过判断调用链的最末端slink特征，从而判断出可利用的gadget chain</li>
</ol>
<a id="more"></a>
<h3 id="0x02-GadgetInspector：入口代码的分析"><a href="#0x02-GadgetInspector：入口代码的分析" class="headerlink" title="0x02 GadgetInspector：入口代码的分析"></a>0x02 GadgetInspector：入口代码的分析</h3><p>程序启动的入口，在该方法中，会做一些数据的准备工作，并一步步调用MethodDiscovery、PassthroughDiscovery、CallGraphDiscovery、SourceDiscovery、GadgetChainDiscovery，最终实现gadget chain的挖掘</p>
<p>参数合法判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (args.length == 0) &#123;</span><br><span class="line">    printUsage();</span><br><span class="line">    System.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序的入口处，会先判断启动参数是否为空，若是空，则直接退出，因为程序对挖掘的gadget chain会有类型的区分，以及class所在位置的配置</p>
<p>日志、序列化类型配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置log4j用于输出日志</span><br><span class="line">configureLogging();</span><br><span class="line"></span><br><span class="line">boolean resume = false;</span><br><span class="line">//挖掘的gadget chain序列化类型，默认java原生序列化</span><br><span class="line">GIConfig config = ConfigRepository.getConfig(&quot;jserial&quot;);</span><br></pre></td></tr></table></figure></p>
<p>日志配置是便于统一的输出管理，而序列化类型的配置，因为对链的挖掘前，我们需要确定挖掘的是哪种类型的链，它可以是jackson的json序列化，也可以是java原生的序列化等等</p>
<p>序列化配置接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface GIConfig &#123;</span><br><span class="line"></span><br><span class="line">    String getName();</span><br><span class="line">    SerializableDecider getSerializableDecider(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap);</span><br><span class="line">    ImplementationFinder getImplementationFinder(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span><br><span class="line">                                                 Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap,</span><br><span class="line">                                                 InheritanceMap inheritanceMap);</span><br><span class="line">    SourceDiscovery getSourceDiscovery();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然我们选择了不同的序列化形式，那么，相对来说，它们都会有自身特有的特征，因此我们需要实现jackson特有的SerializableDecider、ImplementationFinder、SourceDiscovery，从而能达到区分，并最终实现gadget chain的挖掘，</p>
<p>例jackson：</p>
<ul>
<li>SerializableDecider-JacksonSerializableDecider：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class JacksonSerializableDecider implements SerializableDecider &#123;</span><br><span class="line">    //类是否通过决策的缓存集合</span><br><span class="line">    private final Map&lt;ClassReference.Handle, Boolean&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line">    //类名-方法集合 映射集合</span><br><span class="line">    private final Map&lt;ClassReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodsByClassMap;</span><br><span class="line"></span><br><span class="line">    public JacksonSerializableDecider(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap) &#123;</span><br><span class="line">        this.methodsByClassMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            Set&lt;MethodReference.Handle&gt; classMethods = methodsByClassMap.get(method.getClassReference());</span><br><span class="line">            if (classMethods == null) &#123;</span><br><span class="line">                classMethods = new HashSet&lt;&gt;();</span><br><span class="line">                methodsByClassMap.put(method.getClassReference(), classMethods);</span><br><span class="line">            &#125;</span><br><span class="line">            classMethods.add(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Boolean apply(ClassReference.Handle handle) &#123;</span><br><span class="line">        Boolean cached = cache.get(handle);</span><br><span class="line">        if (cached != null) &#123;</span><br><span class="line">            return cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;MethodReference.Handle&gt; classMethods = methodsByClassMap.get(handle);</span><br><span class="line">        if (classMethods != null) &#123;</span><br><span class="line">            for (MethodReference.Handle method : classMethods) &#123;</span><br><span class="line">                //该类，只要有无参构造方法，就通过决策</span><br><span class="line">                if (method.getName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; method.getDesc().equals(&quot;()V&quot;)) &#123;</span><br><span class="line">                    cache.put(handle, Boolean.TRUE);</span><br><span class="line">                    return Boolean.TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache.put(handle, Boolean.FALSE);</span><br><span class="line">        return Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一块代码，我们可以主要关心在apply方法中，可以看到，具体细节的意思就是，只要存在无参的构造方法，都表示可以被序列化。因为在java中，若没有显式的实现无参构造函数，而实现了有参构造函数，在这种情况下，该类是不具有无参构造方法的，而jackson对于json的反序列化，都是先通过无参构造方法进行实例化，因此，若无无参构造方法，则表示不能被jackson进行反序列化。所以，该决策类的存在意义，就是标识gadget chian中不可被反序列化的类，不可被反序列化就意味着数据流不可控，gadget chain无效。</p>
<ul>
<li>ImplementationFinder-JacksonImplementationFinder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JacksonImplementationFinder implements ImplementationFinder &#123;</span><br><span class="line"></span><br><span class="line">    private final SerializableDecider serializableDecider;</span><br><span class="line"></span><br><span class="line">    public JacksonImplementationFinder(SerializableDecider serializableDecider) &#123;</span><br><span class="line">        this.serializableDecider = serializableDecider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target) &#123;</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; allImpls = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // For jackson search, we don&apos;t get to specify the class; it uses reflection to instantiate the</span><br><span class="line">        // class itself. So just add the target method if the target class is serializable.</span><br><span class="line">        if (Boolean.TRUE.equals(serializableDecider.apply(target.getClassReference()))) &#123;</span><br><span class="line">            allImpls.add(target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return allImpls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现类核心方法是getImplementations，因为java是一个多态性的语言，只有在运行时，程序才可知接口的具体实现类是哪一个，而gadgetinspector并不是一个运行时的gadget chain挖掘工具，因此，当遇到一些接口方法的调用时，需要通过查找该接口方法的所有实现类，并把它们组成链的一节形成实际调用的链，最后去进行污点分析。而该方法通过调用JacksonSerializableDecider的apply方法进行判断，因为对于接口或者子类的实现，我们是可控的，但是该json是否可被反序列化，需要通过JacksonSerializableDecider判断是否存在无参构造方法。</p>
<ul>
<li>SourceDiscovery-JacksonSourceDiscovery</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class JacksonSourceDiscovery extends SourceDiscovery &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span><br><span class="line">                         InheritanceMap inheritanceMap) &#123;</span><br><span class="line"></span><br><span class="line">        final JacksonSerializableDecider serializableDecider = new JacksonSerializableDecider(methodMap);</span><br><span class="line"></span><br><span class="line">        for (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            if (serializableDecider.apply(method.getClassReference())) &#123;</span><br><span class="line">                if (method.getName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; method.getDesc().equals(&quot;()V&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">                if (method.getName().startsWith(&quot;get&quot;) &amp;&amp; method.getDesc().startsWith(&quot;()&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">                if (method.getName().startsWith(&quot;set&quot;) &amp;&amp; method.getDesc().matches(&quot;\\(L[^;]*;\\)V&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现类，仅有discover这一个方法，不过，对于gadget chain的挖掘，它可以肯定是最重要的，因为一个gadget chain的执行链，我们必须要有一个可以触发的入口，而JacksonSourceDiscovery的作用就是找出具备这样特征的入口方法，对于jackson反序列化json时，它会执行无参构造方法以及setter、getter方法，若我们在数据字段可控的情况下，并由这些被执行的方法去触发，若存在gadget chain，那么就能触发source-slink整条链的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int argIndex = 0;</span><br><span class="line">while (argIndex &lt; args.length) &#123;</span><br><span class="line">    String arg = args[argIndex];</span><br><span class="line">    if (!arg.startsWith(&quot;--&quot;)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arg.equals(&quot;--resume&quot;)) &#123;</span><br><span class="line">        //不删除dat文件</span><br><span class="line">        resume = true;</span><br><span class="line">    &#125; else if (arg.equals(&quot;--config&quot;)) &#123;</span><br><span class="line">        //--config参数指定序列化类型</span><br><span class="line">        config = ConfigRepository.getConfig(args[++argIndex]);</span><br><span class="line">        if (config == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid config name: &quot; + args[argIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unexpected argument: &quot; + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argIndex += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处是对于一些参数的一些解析配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--resume：不删除dat文件</span><br><span class="line">--config：指定序列化类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final ClassLoader classLoader;</span><br><span class="line">//程序参数的最后一部分，即最后一个具有前缀--的参数（例：--resume）后</span><br><span class="line">if (args.length == argIndex+1 &amp;&amp; args[argIndex].toLowerCase().endsWith(&quot;.war&quot;)) &#123;</span><br><span class="line">    //加载war文件</span><br><span class="line">    Path path = Paths.get(args[argIndex]);</span><br><span class="line">    LOGGER.info(&quot;Using WAR classpath: &quot; + path);</span><br><span class="line">    //实现为URLClassLoader，加载war包下的WEB-INF/lib和WEB-INF/classes</span><br><span class="line">    classLoader = Util.getWarClassLoader(path);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //加载jar文件，java命令后部，可配置多个</span><br><span class="line">    final Path[] jarPaths = new Path[args.length - argIndex];</span><br><span class="line">    for (int i = 0; i &lt; args.length - argIndex; i++) &#123;</span><br><span class="line">        Path path = Paths.get(args[argIndex + i]).toAbsolutePath();</span><br><span class="line">        if (!Files.exists(path)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid jar path: &quot; + path);</span><br><span class="line">        &#125;</span><br><span class="line">        jarPaths[i] = path;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(&quot;Using classpath: &quot; + Arrays.toString(jarPaths));</span><br><span class="line">    //实现为URLClassLoader，加载所有指定的jar</span><br><span class="line">    classLoader = Util.getJarClassLoader(jarPaths);</span><br><span class="line">&#125;</span><br><span class="line">//类枚举加载器，具有两个方法</span><br><span class="line">//getRuntimeClasses获取rt.jar的所有class</span><br><span class="line">//getAllClasses获取rt.jar以及classLoader加载的class</span><br><span class="line">final ClassResourceEnumerator classResourceEnumerator = new ClassResourceEnumerator(classLoader);</span><br></pre></td></tr></table></figure>
<p>这段代码，解析了程序启动参数最后一个“–参数”后的部分，这部分可以指定一个war包，也能指定多个jar包，并最终放到ClassResourceEnumerator，ClassResourceEnumerator通过guava的ClassPath，对配置加载的war、jar中的所有class进行读取或对jre的rt.jar中的所有class进行读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//删除所有的dat文件</span><br><span class="line">if (!resume) &#123;</span><br><span class="line">    // Delete all existing dat files</span><br><span class="line">    LOGGER.info(&quot;Deleting stale data...&quot;);</span><br><span class="line">    for (String datFile : Arrays.asList(&quot;classes.dat&quot;, &quot;methods.dat&quot;, &quot;inheritanceMap.dat&quot;,</span><br><span class="line">            &quot;passthrough.dat&quot;, &quot;callgraph.dat&quot;, &quot;sources.dat&quot;, &quot;methodimpl.dat&quot;)) &#123;</span><br><span class="line">        final Path path = Paths.get(datFile);</span><br><span class="line">        if (Files.exists(path)) &#123;</span><br><span class="line">            Files.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，可以看到，如果没有配置–resume参数，那么在程序的每次启动后，都会先删除所有的dat文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//扫描java runtime所有的class（rt.jar）和指定的jar或war中的所有class</span><br><span class="line"></span><br><span class="line">// Perform the various discovery steps</span><br><span class="line">if (!Files.exists(Paths.get(&quot;classes.dat&quot;)) || !Files.exists(Paths.get(&quot;methods.dat&quot;))</span><br><span class="line">        || !Files.exists(Paths.get(&quot;inheritanceMap.dat&quot;))) &#123;</span><br><span class="line">    LOGGER.info(&quot;Running method discovery...&quot;);</span><br><span class="line">    MethodDiscovery methodDiscovery = new MethodDiscovery();</span><br><span class="line">    methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">    //保存了类信息、方法信息、继承实现信息</span><br><span class="line">    methodDiscovery.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!Files.exists(Paths.get(&quot;passthrough.dat&quot;))) &#123;</span><br><span class="line">    LOGGER.info(&quot;Analyzing methods for passthrough dataflow...&quot;);</span><br><span class="line">    PassthroughDiscovery passthroughDiscovery = new PassthroughDiscovery();</span><br><span class="line">    //记录参数在方法调用链中的流动关联（如：A、B、C、D四个方法，调用链为A-&gt;B B-&gt;C C-&gt;D，其中参数随着调用关系从A流向B，在B调用C过程中作为入参并随着方法结束返回，最后流向D）</span><br><span class="line">    //该方法主要是追踪上面所说的&quot;B调用C过程中作为入参并随着方法结束返回&quot;，入参和返回值之间的关联</span><br><span class="line">    passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    passthroughDiscovery.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!Files.exists(Paths.get(&quot;callgraph.dat&quot;))) &#123;</span><br><span class="line">    LOGGER.info(&quot;Analyzing methods in order to build a call graph...&quot;);</span><br><span class="line">    CallGraphDiscovery callGraphDiscovery = new CallGraphDiscovery();</span><br><span class="line">    //记录参数在方法调用链中的流动关联（如：A、B、C三个方法，调用链为A-&gt;B B-&gt;C，其中参数随着调用关系从A流向B，最后流C）</span><br><span class="line">    //该方法主要是追踪上面所说的参数流动，即A-&gt;B入参和B-&gt;C入参的关系，以确定参数可控</span><br><span class="line">    callGraphDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    callGraphDiscovery.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!Files.exists(Paths.get(&quot;sources.dat&quot;))) &#123;</span><br><span class="line">    LOGGER.info(&quot;Discovering gadget chain source methods...&quot;);</span><br><span class="line">    SourceDiscovery sourceDiscovery = config.getSourceDiscovery();</span><br><span class="line">    //查找利用链的入口（例：java原生反序列化的readObject）</span><br><span class="line">    sourceDiscovery.discover();</span><br><span class="line">    sourceDiscovery.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    LOGGER.info(&quot;Searching call graph for gadget chains...&quot;);</span><br><span class="line">    GadgetChainDiscovery gadgetChainDiscovery = new GadgetChainDiscovery(config);</span><br><span class="line">    //根据上面的数据收集，最终分析利用链</span><br><span class="line">    gadgetChainDiscovery.discover();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOGGER.info(&quot;Analysis complete!&quot;);</span><br></pre></td></tr></table></figure>
<p>最后这部分，就是核心的挖掘逻辑。</p>
<h3 id="0x03-MethodDiscovery"><a href="#0x03-MethodDiscovery" class="headerlink" title="0x03 MethodDiscovery"></a>0x03 MethodDiscovery</h3><p>这部分，主要进行了类数据、方法数据以及类继承关系数据的收集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!Files.exists(Paths.get(&quot;classes.dat&quot;)) || !Files.exists(Paths.get(&quot;methods.dat&quot;))</span><br><span class="line">        || !Files.exists(Paths.get(&quot;inheritanceMap.dat&quot;))) &#123;</span><br><span class="line">    LOGGER.info(&quot;Running method discovery...&quot;);</span><br><span class="line">    MethodDiscovery methodDiscovery = new MethodDiscovery();</span><br><span class="line">    methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">    //保存了类信息、方法信息、继承实现信息</span><br><span class="line">    methodDiscovery.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码可以看到，先判断了classes.dat、methods.dat、inheritanceMap.dat三个文件是否存在，若不存在则执行MethodDiscovery的实例化，并依次调用其discover、save方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void discover(final ClassResourceEnumerator classResourceEnumerator) throws Exception &#123;</span><br><span class="line">    for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        try (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">            ClassReader cr = new ClassReader(in);</span><br><span class="line">            try &#123;</span><br><span class="line">                //使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录</span><br><span class="line">                cr.accept(new MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOGGER.error(&quot;Exception analyzing: &quot; + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodDiscovery.discover方法中，通过调用classResourceEnumerator.getAllClasses()获取到rt.jar以及程序参数配置的jar、war中所有的class，然后遍历每一个class，接着通过ASM，对其每个类进行观察者模式的visit</p>
<p>跟进MethodDiscoveryClassVisitor，对于ClassVisitor，ASM对其每个方法的调用顺序是这样的：</p>
<p><strong>visit顺序：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void visit(int version, int access, String name, String signature, String superName, String[] interfaces)</span><br><span class="line">visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void visitSource(String source, String debug)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void visitOuterClass(String owner, String name, String descriptor)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void visitAttribute(Attribute attribute)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnnotationVisitor visitAnnotation(String descriptor, boolean visible)</span><br><span class="line">visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void visit*()</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void visitEnd()</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value)</span><br><span class="line">visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</span><br></pre></td></tr></table></figure></p>
<p>-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions)</span><br><span class="line">visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</span><br></pre></td></tr></table></figure></p>
<p>那么，跟进这个调用顺序，我们跟进其实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class MethodDiscoveryClassVisitor extends ClassVisitor &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String superName;</span><br><span class="line">    private String[] interfaces;</span><br><span class="line">    boolean isInterface;</span><br><span class="line">    private List&lt;ClassReference.Member&gt; members;//类的所有字段</span><br><span class="line">    private ClassReference.Handle classHandle;</span><br><span class="line"></span><br><span class="line">    private MethodDiscoveryClassVisitor() throws SQLException &#123;</span><br><span class="line">        super(Opcodes.ASM6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit ( int version, int access, String name, String signature, String superName, String[]interfaces)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.superName = superName;</span><br><span class="line">        this.interfaces = interfaces;</span><br><span class="line">        this.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != 0;</span><br><span class="line">        this.members = new ArrayList&lt;&gt;();</span><br><span class="line">        this.classHandle = new ClassReference.Handle(name);//类名</span><br><span class="line"></span><br><span class="line">        super.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>visit()这个方法，会在类被观察的第一时间执行。可以看到在visit()这个方法执行时，保存了当前观察类的一些信息：</p>
<ol>
<li>this.name：类名</li>
<li>this.superName：继承的父类名</li>
<li>this.interfaces：实现的接口名</li>
<li>this.isInterface：当前类是否接口</li>
<li>this.members：类的字段集合</li>
<li>this.classHandle：gadgetinspector中对于类名的封装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public FieldVisitor visitField(int access, String name, String desc,</span><br><span class="line">                               String signature, Object value) &#123;</span><br><span class="line">    if ((access &amp; Opcodes.ACC_STATIC) == 0) &#123;</span><br><span class="line">        Type type = Type.getType(desc);</span><br><span class="line">        String typeName;</span><br><span class="line">        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;</span><br><span class="line">            typeName = type.getInternalName();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            typeName = type.getDescriptor();</span><br><span class="line">        &#125;</span><br><span class="line">        members.add(new ClassReference.Member(name, access, new ClassReference.Handle(typeName)));</span><br><span class="line">    &#125;</span><br><span class="line">    return super.visitField(access, name, desc, signature, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，被观察类若存在多少个field字段，那么visitField()这个方法，就会被调用多少次，每调用一次，就代表一个字段。看实现代码，visitField()方法在被调用时，会通过判断字段的类型去生成typeName类型名称，最后添加到visit()方法中初始化的this.members集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">    boolean isStatic = (access &amp; Opcodes.ACC_STATIC) != 0;</span><br><span class="line">    //找到一个方法，添加到缓存</span><br><span class="line">    discoveredMethods.add(new MethodReference(</span><br><span class="line">            classHandle,//类名</span><br><span class="line">            name,</span><br><span class="line">            desc,</span><br><span class="line">            isStatic));</span><br><span class="line">    return super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而被观察类若存在多少个方法，那么visitMethod()这个方法，就会被调用多少次，每调用一次，就代表一个方法，看上述代码，可以清楚的看到，其对方法进行了收集，并缓存在this.discoveredMethods中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitEnd() &#123;</span><br><span class="line">    ClassReference classReference = new ClassReference(</span><br><span class="line">            name,</span><br><span class="line">            superName,</span><br><span class="line">            interfaces,</span><br><span class="line">            isInterface,</span><br><span class="line">            members.toArray(new ClassReference.Member[members.size()]));//把所有找到的字段封装</span><br><span class="line">    //找到一个方法遍历完成后，添加类到缓存</span><br><span class="line">    discoveredClasses.add(classReference);</span><br><span class="line"></span><br><span class="line">    super.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在每一个visit*方法被执行后，最后一个执行的方法就是visitEnd()，在这段代码中，把当前的被观察的类信息缓存到了this.discoveredClasses，其中包括前面visitField阶段收集到的所有字段members</p>
<p>至此，MethodDiscovery.discover方法就执行完毕了，而下一步就是MethodDiscovery.save方法的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void save() throws IOException &#123;</span><br><span class="line">    //保存和读取使用Factory实现</span><br><span class="line"></span><br><span class="line">    //classes.dat数据格式：</span><br><span class="line">    //类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型</span><br><span class="line">    DataLoader.saveData(Paths.get(&quot;classes.dat&quot;), new ClassReference.Factory(), discoveredClasses);</span><br><span class="line"></span><br><span class="line">    //methods.dat数据格式：</span><br><span class="line">    //类名 方法名 方法描述 是否静态方法</span><br><span class="line">    DataLoader.saveData(Paths.get(&quot;methods.dat&quot;), new MethodReference.Factory(), discoveredMethods);</span><br><span class="line"></span><br><span class="line">    //形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">        classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    //保存classes.dat和methods.dat的同时，对所有的class进行递归整合，得到集合&#123;class:[subclass]&#125;，</span><br><span class="line">    // class为subclass父类、超类或实现的接口类，保存至inheritanceMap.dat</span><br><span class="line">    InheritanceDeriver.derive(classMap).save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过DataLoader.saveData保存了收集到的discoveredClasses类信息以及discoveredMethods方法信息，对于这些信息的存储格式，通过了ClassReference.Factory()、MethodReference.Factory()进行实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void saveData(Path filePath, DataFactory&lt;T&gt; factory, Collection&lt;T&gt; values) throws IOException &#123;</span><br><span class="line">    try (BufferedWriter writer = Files.newWriter(filePath.toFile(), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        for (T value : values) &#123;</span><br><span class="line">            final String[] fields = factory.serialize(value);</span><br><span class="line">            if (fields == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for (String field : fields) &#123;</span><br><span class="line">                if (field == null) &#123;</span><br><span class="line">                    sb.append(&quot;\t&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sb.append(&quot;\t&quot;).append(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(sb.substring(1));</span><br><span class="line">            writer.write(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>saveData方法中会通过调用factory的serialize对数据进行序列化，然后一行一行的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static class Factory implements DataFactory&lt;ClassReference&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(ClassReference obj) &#123;</span><br><span class="line">        String interfaces;</span><br><span class="line">        if (obj.interfaces.length &gt; 0) &#123;</span><br><span class="line">            StringBuilder interfacesSb = new StringBuilder();</span><br><span class="line">            for (String iface : obj.interfaces) &#123;</span><br><span class="line">                interfacesSb.append(&quot;,&quot;).append(iface);</span><br><span class="line">            &#125;</span><br><span class="line">            interfaces = interfacesSb.substring(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            interfaces = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder members = new StringBuilder();</span><br><span class="line">        for (Member member : obj.members) &#123;</span><br><span class="line">            members.append(&quot;!&quot;).append(member.getName())</span><br><span class="line">                    .append(&quot;!&quot;).append(Integer.toString(member.getModifiers()))</span><br><span class="line">                    .append(&quot;!&quot;).append(member.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new String[]&#123;</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.superClass,</span><br><span class="line">                interfaces,</span><br><span class="line">                Boolean.toString(obj.isInterface),</span><br><span class="line">                members.length() == 0 ? null : members.substring(1)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static class Factory implements DataFactory&lt;MethodReference&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(MethodReference obj) &#123;</span><br><span class="line">        return new String[] &#123;</span><br><span class="line">                obj.classReference.getName(),</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.desc,</span><br><span class="line">                Boolean.toString(obj.isStatic),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于类信息的存储，最终形成classes.dat文件的数据格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型</span><br></pre></td></tr></table></figure>
<p>对于方法信息的存储，最终形成methods.dat文件的数据格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述 是否静态方法</span><br></pre></td></tr></table></figure>
<p>在对类、方法信息存储后，会再进一步利用已得到的类信息，进行类继承、实现关系的整合分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = new HashMap&lt;&gt;();</span><br><span class="line">for (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">    classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">&#125;</span><br><span class="line">//保存classes.dat和methods.dat的同时，对所有的class进行递归整合，得到集合&#123;class:[subclass]&#125;，</span><br><span class="line">// class为subclass父类、超类或实现的接口类，保存至inheritanceMap.dat</span><br><span class="line">InheritanceDeriver.derive(classMap).save();</span><br></pre></td></tr></table></figure>
<p>核心实现位于InheritanceDeriver.derive方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static InheritanceMap derive(Map&lt;ClassReference.Handle, ClassReference&gt; classMap) &#123;</span><br><span class="line">    LOGGER.debug(&quot;Calculating inheritance for &quot; + (classMap.size()) + &quot; classes...&quot;);</span><br><span class="line">    Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; implicitInheritance = new HashMap&lt;&gt;();</span><br><span class="line">    //遍历所有类</span><br><span class="line">    for (ClassReference classReference : classMap.values()) &#123;</span><br><span class="line">        if (implicitInheritance.containsKey(classReference.getHandle())) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Already derived implicit classes for &quot; + classReference.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; allParents = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //获取classReference的所有父类、超类、接口类</span><br><span class="line">        getAllParents(classReference, classMap, allParents);</span><br><span class="line">        //添加缓存：类名 -&gt; 所有的父类、超类、接口类</span><br><span class="line">        implicitInheritance.put(classReference.getHandle(), allParents);</span><br><span class="line">    &#125;</span><br><span class="line">    //InheritanceMap翻转集合，转换为&#123;class:[subclass]&#125;</span><br><span class="line">    return new InheritanceMap(implicitInheritance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取classReference的所有父类、超类、接口类</span><br><span class="line"> *</span><br><span class="line"> * @param classReference</span><br><span class="line"> * @param classMap</span><br><span class="line"> * @param allParents</span><br><span class="line"> */</span><br><span class="line">private static void getAllParents(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents) &#123;</span><br><span class="line">    Set&lt;ClassReference.Handle&gt; parents = new HashSet&lt;&gt;();</span><br><span class="line">    //把当前classReference类的父类添加到parents</span><br><span class="line">    if (classReference.getSuperClass() != null) &#123;</span><br><span class="line">        parents.add(new ClassReference.Handle(classReference.getSuperClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    //把当前classReference类实现的所有接口添加到parents</span><br><span class="line">    for (String iface : classReference.getInterfaces()) &#123;</span><br><span class="line">        parents.add(new ClassReference.Handle(iface));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (ClassReference.Handle immediateParent : parents) &#123;</span><br><span class="line">        //从所有类数据集合中，遍历找出classReference的父类、接口</span><br><span class="line">        ClassReference parentClassReference = classMap.get(immediateParent);</span><br><span class="line">        if (parentClassReference == null) &#123;</span><br><span class="line">            LOGGER.debug(&quot;No class id for &quot; + immediateParent.getName());</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //继续添加到集合中</span><br><span class="line">        allParents.add(parentClassReference.getHandle());</span><br><span class="line">        //继续递归查找，直到把classReference类的所有父类、超类、接口类都添加到allParents</span><br><span class="line">        getAllParents(parentClassReference, classMap, allParents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面类信息的收集保存，其得到的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型</span><br></pre></td></tr></table></figure>
<p>通过这些信息，可以清楚的知道每个类继承的父类、实现的接口类，因此，通过遍历每一个类，并且通过递归的方式，从而一路向上查找收集，最终形成了父子、超类间的关系集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 -&gt; 所有的父类、超类、接口类</span><br></pre></td></tr></table></figure>
<p>并在实例化InheritanceMap返回时，在其构造方法中，对关系集合进行了逆向的整合，最终形成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 -&gt; 所有的子孙类、实现类</span><br></pre></td></tr></table></figure>
<p>构造方法细节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritanceMap &#123;</span><br><span class="line">    //子-父关系集合</span><br><span class="line">    private final Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap;</span><br><span class="line">    //父-子关系集合</span><br><span class="line">    private final Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap;</span><br><span class="line"></span><br><span class="line">    public InheritanceMap(Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap) &#123;</span><br><span class="line">        this.inheritanceMap = inheritanceMap;</span><br><span class="line">        subClassMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">            ClassReference.Handle child = entry.getKey();</span><br><span class="line">            for (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">                subClassMap.computeIfAbsent(parent, k -&gt; new HashSet&lt;&gt;()).add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，对于收集到的继承、实现关系数据，通过调用InheritanceDeriver.save方法，在其内部调用DataLoader.saveData并通过InheritanceMapFactory的序列化方法，对数据进行保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void save() throws IOException &#123;</span><br><span class="line">    //inheritanceMap.dat数据格式：</span><br><span class="line">    //类名 父类或超类或接口类1 父类或超类或接口类2 父类或超类或接口类3 ...</span><br><span class="line">    DataLoader.saveData(Paths.get(&quot;inheritanceMap.dat&quot;), new InheritanceMapFactory(), inheritanceMap.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class InheritanceMapFactory implements DataFactory&lt;Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; obj) &#123;</span><br><span class="line">        final String[] fields = new String[obj.getValue().size()+1];</span><br><span class="line">        fields[0] = obj.getKey().getName();</span><br><span class="line">        int i = 1;</span><br><span class="line">        for (ClassReference.Handle handle : obj.getValue()) &#123;</span><br><span class="line">            fields[i++] = handle.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        return fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终保存到inheritanceMap.dat文件中的数据格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 父类或超类或接口类1 父类或超类或接口类2 父类或超类或接口类3 ...</span><br></pre></td></tr></table></figure>
<h3 id="0x04-方法入参和返回值污点分析-PassthroughDiscovery"><a href="#0x04-方法入参和返回值污点分析-PassthroughDiscovery" class="headerlink" title="0x04 方法入参和返回值污点分析-PassthroughDiscovery"></a>0x04 方法入参和返回值污点分析-PassthroughDiscovery</h3><p>在这一小节中，我主要讲解的是PassthroughDiscovery中的代码，该部分也是整个gadgetinspector中比较核心的部分，我在阅读相关代码的时候，通过查看网络上的一些资料、博文，他们对于大体原理的讲解，都分析得比较详细，其中有一篇<a href="https://paper.seebug.org/1034/，个人觉得讲得非常不错，其中就有关于逆拓扑结构等部分，在阅读本文章的时候，大家可以同时阅读这篇文章，相互结合着看，会有意向不到的效果，但该文章也有部分细节讲得不够透彻，其中就有ASM实现细节部分，而本篇文章，这一部分章节部分原因是为了弥补它的细节不足处而编写，还有就是主要为了阐述我对gadgetinspector的理解。" target="_blank" rel="noopener">https://paper.seebug.org/1034/，个人觉得讲得非常不错，其中就有关于逆拓扑结构等部分，在阅读本文章的时候，大家可以同时阅读这篇文章，相互结合着看，会有意向不到的效果，但该文章也有部分细节讲得不够透彻，其中就有ASM实现细节部分，而本篇文章，这一部分章节部分原因是为了弥补它的细节不足处而编写，还有就是主要为了阐述我对gadgetinspector的理解。</a></p>
<p>在讲这部分代码之前，我想要展示一个代码例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method(args);</span><br><span class="line">    Runtime.getRuntime().exec(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">  public String method(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码，我们可以看到类A和方法method，方法method接收到参数后，通过return返回，接着赋值给main方法中的cmd变量，最后Runtime.exec执行命令。</p>
<p>所以，根据上面代码展示，我们只要能控制method这个方法的入参，就能控制其方法的返回值，并控制数据流最终流向Runtime.exec。这其实类似于污点分析，而在PassthroughDiscovery这个类的处理阶段中，最主要就是做这样的一件事，通过不断的分析所有的方法，它们是否会被入参所污染。</p>
<p>还有就是，方法数据流的传递，不仅仅是一层两层，可能在整个gadget chain中，会牵涉到非常之多的方法，那么，对于所有方法数据流的污点分析，其分析顺序将会是成功与否的前提条件。这边继续讲一个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method1(args);</span><br><span class="line">    new B().method2(cmd);</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">  public void method2(String param) throws IOException &#123;</span><br><span class="line">    new C().method3(param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C &#123;</span><br><span class="line">  public void method3(String param) throws IOException &#123;</span><br><span class="line">    Runtime.getRuntime().exec(param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，可以看到source-slink之间的具体流程，经过数据流的污点分析，我们可以得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A$method1-1</span><br><span class="line">B$method2-1</span><br><span class="line">C$method3-1</span><br></pre></td></tr></table></figure>
<p>从代码上分析，因为A.method1的入参我们可以控制，并且其返回值间接的也被入参控制，接着赋值给了cmd变量，那么就表示cmd这个变量我们也是可以控制的，接着调用B.method2，cmd变量作为入参，并接着再把其入参作为C.method3的入参，最终走到Runtime.getRuntime().exec(param)，那么，就意味着只要我们控制了A.method1的入参，最终我们可以通过这个数据，最终影响整个source-&gt;slink，并最终得到执行exec。</p>
<p>而从上面的代码流程，我们只要搞明白了A类的method1方法、B类的method2方法以及C类的method3方法能被哪个参数污染下去，那么，我们就能确定整个source至slink的污点传递，但是，这里有个问题，在得到B类的method2方法参数的污染结果之前，必须得先把C类的method3方法参数的污染结果得到，而具体怎么做到呢？在gadgetinspector中，通过了DTS，一种逆拓扑顺序的方式，先得到方法执行链的逆序排序的方法集合，然后由此，从最末端进行参数污点分析，倒着回来，也就是，我先确认C类的method3方法参数的污染结果，并存储起来，接着进行分析B类的method2方法的时候，就能根据前面得到的结果，继续分析下去，最后得到B类的method2方法的参数污染结果。</p>
<p>那么，逆拓扑顺序的具体代码实现是如何呢？</p>
<p>我们跟进passthroughDiscovery.discover方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//加载文件记录的所有方法信息</span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">//加载文件记录的所有类信息</span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">//加载文件记录的所有类继承、实现关联信息</span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br></pre></td></tr></table></figure></p>
<p>可以看到前三个操作分别是加载前面MethodDiscovery收集到的类、方法、继承实现的信息</p>
<p>接着，调用discoverMethodCalls方法，整理出所有方法，调用者方法caller和被调用者target方法之间映射的集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//搜索方法间的调用关系，缓存至methodCalls集合，返回 类名-&gt;类资源 映射集合</span><br><span class="line">Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br></pre></td></tr></table></figure></p>
<p>通过ASM Visitor的方式，使用MethodCallDiscoveryClassVisitor这个ClassVisitor实现类进行方法调用的收集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(final ClassResourceEnumerator classResourceEnumerator) throws IOException &#123;</span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = new HashMap&lt;&gt;();</span><br><span class="line">    for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        try (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">            ClassReader cr = new ClassReader(in);</span><br><span class="line">            try &#123;</span><br><span class="line">                MethodCallDiscoveryClassVisitor visitor = new MethodCallDiscoveryClassVisitor(Opcodes.ASM6);</span><br><span class="line">                cr.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                classResourcesByName.put(visitor.getName(), classResource);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOGGER.error(&quot;Error analyzing: &quot; + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return classResourcesByName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MethodCallDiscoveryClassVisitor中的运转流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private class MethodCallDiscoveryClassVisitor extends ClassVisitor &#123;</span><br><span class="line">    public MethodCallDiscoveryClassVisitor(int api) &#123;</span><br><span class="line">        super(api);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(int version, int access, String name, String signature,</span><br><span class="line">                      String superName, String[] interfaces) &#123;</span><br><span class="line">        super.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        if (this.name != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;ClassVisitor already visited a class!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc,</span><br><span class="line">                                     String signature, String[] exceptions) &#123;</span><br><span class="line">        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        //在visit每个method的时候，创建MethodVisitor对method进行观察</span><br><span class="line">        MethodCallDiscoveryMethodVisitor modelGeneratorMethodVisitor = new MethodCallDiscoveryMethodVisitor(</span><br><span class="line">                api, mv, this.name, name, desc);</span><br><span class="line"></span><br><span class="line">        return new JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitEnd() &#123;</span><br><span class="line">        super.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的执行顺序是visit-&gt;visitMethod-&gt;visitEnd，前面也说过了，ASM对于观察者模式的具体表现。</p>
<ul>
<li>visit：在这个方法中，把当前观察的类名赋值到了this.name</li>
<li>visitMethod：在这个方法中，继续进一步的对被观察类的每一个方法细节进行观察</li>
</ul>
<p>继续进一步对方法的观察实现类是MethodCallDiscoveryMethodVisitor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private class MethodCallDiscoveryMethodVisitor extends MethodVisitor &#123;</span><br><span class="line">    private final Set&lt;MethodReference.Handle&gt; calledMethods;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param api</span><br><span class="line">     * @param mv</span><br><span class="line">     * @param owner 上一步ClassVisitor在visitMethod时，传入的当前class</span><br><span class="line">     * @param name visit的方法名</span><br><span class="line">     * @param desc visit的方法描述</span><br><span class="line">     */</span><br><span class="line">    public MethodCallDiscoveryMethodVisitor(final int api, final MethodVisitor mv,</span><br><span class="line">                                       final String owner, String name, String desc) &#123;</span><br><span class="line">        super(api, mv);</span><br><span class="line"></span><br><span class="line">        //创建calledMethod收集调用到的method，最后形成集合&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125;</span><br><span class="line">        this.calledMethods = new HashSet&lt;&gt;();</span><br><span class="line">        methodCalls.put(new MethodReference.Handle(new ClassReference.Handle(owner), name, desc), calledMethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法内，每一个方法调用都会执行该方法</span><br><span class="line">     *</span><br><span class="line">     * @param opcode 调用操作码：INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.</span><br><span class="line">     * @param owner 被调用的类名</span><br><span class="line">     * @param name 被调用的方法</span><br><span class="line">     * @param desc 被调用方法的描述</span><br><span class="line">     * @param itf 被调用的类是否接口</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">        calledMethods.add(new MethodReference.Handle(new ClassReference.Handle(owner), name, desc));</span><br><span class="line">        super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的代码，我这里也做了比较详细的注释，在MethodCallDiscoveryMethodVisitor构造方法执行的时候，会对this.calledMethods集合进行初始化，该集合的主要作用是在被观察方法对其他方法进行调用时（会执行visitMethodInsn方法），用于缓存记录被调用的方法，因此，我们可以看到visitMethodInsn方法中，执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calledMethods.add(new MethodReference.Handle(new ClassReference.Handle(owner), name, desc));</span><br></pre></td></tr></table></figure>
<p>并且在构造方法执行的时候，集合calledMethods也会被添加到gadgetinspector.PassthroughDiscovery#methodCalls中，做全局性的收集，因此，最后我们能通过discoverMethodCalls这一个方法，实现对这样一个数据的全量收集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125;</span><br><span class="line">收集哪个class的method调用了哪一个class的method关系集合</span><br></pre></td></tr></table></figure>
<p>接着，在下一步，通过调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br></pre></td></tr></table></figure></p>
<p>完成了对上述收集到的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>实现逆拓扑的排序，跟进topologicallySortMethodCalls方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = new HashMap&lt;&gt;();</span><br><span class="line">for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">    MethodReference.Handle method = entry.getKey();</span><br><span class="line">    outgoingReferences.put(method, new HashSet&lt;&gt;(entry.getValue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步，对methodCalls的数据进行了封装整理，形成了Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt;这样结构的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Topological sort methods</span><br><span class="line">LOGGER.debug(&quot;Performing topological sort...&quot;);</span><br><span class="line">Set&lt;MethodReference.Handle&gt; dfsStack = new HashSet&lt;&gt;();</span><br><span class="line">Set&lt;MethodReference.Handle&gt; visitedNodes = new HashSet&lt;&gt;();</span><br><span class="line">List&lt;MethodReference.Handle&gt; sortedMethods = new ArrayList&lt;&gt;(outgoingReferences.size());</span><br><span class="line">for (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">    //遍历集合中的起始方法，进行递归搜索DFS，通过逆拓扑排序，调用链的最末端排在最前面，</span><br><span class="line">    // 这样才能实现入参、返回值、函数调用链之间的污点影响</span><br><span class="line">    dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">&#125;</span><br><span class="line">LOGGER.debug(String.format(&quot;Outgoing references %d, sortedMethods %d&quot;, outgoingReferences.size(), sortedMethods.size()));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void dfsTsort(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span><br><span class="line">                            List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span><br><span class="line">                            Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node) &#123;</span><br><span class="line"></span><br><span class="line">if (stack.contains(node)) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">if (visitedNodes.contains(node)) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">//根据起始方法，取出被调用的方法集</span><br><span class="line">Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">if (outgoingRefs == null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入栈，以便于递归不造成类似循环引用的死循环整合</span><br><span class="line">stack.add(node);</span><br><span class="line">for (MethodReference.Handle child : outgoingRefs) &#123;</span><br><span class="line">    dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">&#125;</span><br><span class="line">stack.remove(node);</span><br><span class="line">visitedNodes.add(node);//记录已被探索过的方法，用于在上层调用遇到重复方法时可以跳过</span><br><span class="line">sortedMethods.add(node);//递归完成的探索，会添加进来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，通过遍历每个方法，并调用dfsTsort实现逆拓扑排序，具体细节示意图，我前面推荐的那篇文章画得非常不错，建议此时去看看</p>
<ol>
<li>dfsStack用于在在逆拓扑时候不会形成环</li>
<li>visitedNodes在一条调用链出现重合的时候，不会造成重复的排序</li>
<li>sortedMethods最终逆拓扑排序出来的结果集合</li>
</ol>
<p>最终，实现的效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method1(args);</span><br><span class="line">    new B().method2(cmd);</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">  public void method2(String param) throws IOException &#123;</span><br><span class="line">    new C().method3(param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C &#123;</span><br><span class="line">  public void method3(String param) throws IOException &#123;</span><br><span class="line">    Runtime.getRuntime().exec(param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用链main-&gt;A.method1,main-&gt;B.method2-&gt;C.method3</p>
<p>排序后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.method1</span><br><span class="line">C.method3</span><br><span class="line">B.method2</span><br><span class="line">main</span><br></pre></td></tr></table></figure>
<p>通过这样的一个结果，就如我们前面所讲的，就能在污点分析方法参数的时候，根据这个排序后的集合顺序进行分析，从而在最末端开始进行，在上一层也能通过缓存取到下层方法已经过污点分析的结果，继而继续走下去。</p>
<p>这些，便是逆拓扑排序的实现以及意义。</p>
<p>接着，就到重头戏了，我这篇文章最想要描述的ASM怎么进行参数和返回结果之间的污点分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * classResourceByName：类资源集合</span><br><span class="line"> * classMap：类信息集合</span><br><span class="line"> * inheritanceMap：继承、实现关系集合</span><br><span class="line"> * sortedMethods：方法集合</span><br><span class="line"> * SerializableDecider：决策者</span><br><span class="line"> */</span><br><span class="line">passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">        config.getSerializableDecider(methodMap, inheritanceMap));</span><br></pre></td></tr></table></figure>
<p>跟进calculatePassthroughDataflow这个方法</p>
<p>首先，会初始化一个集合，用于收集污染结果，key对应方法名，value对应可以污染下去的参数索引集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>紧接着，遍历被排序过后的方法，并跳过static静态初始化方法，因为静态代码块我们基本上是没办法污染的，其执行的时机在类加载的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//遍历所有方法，然后asm观察所属类，经过前面DFS的排序，调用链最末端的方法在最前面</span><br><span class="line">for (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">    //跳过static静态初始化代码</span><br><span class="line">    if (method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后根据方法信息，获取到所属的类，接着通过ASM对其进行观察<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//获取所属类进行观察</span><br><span class="line">ClassResourceEnumerator.ClassResource classResource = classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">try (InputStream inputStream = classResource.getInputStream()) &#123;</span><br><span class="line">    ClassReader cr = new ClassReader(inputStream);</span><br><span class="line">    try &#123;</span><br><span class="line">        PassthroughDataflowClassVisitor cv = new PassthroughDataflowClassVisitor(classMap, inheritanceMap,</span><br><span class="line">                passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">        cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        passthroughDataflow.put(method, cv.getReturnTaint());//缓存方法返回值与哪个参数有关系</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOGGER.error(&quot;Exception analyzing &quot; + method.getClassReference().getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    LOGGER.error(&quot;Unable to analyze &quot; + method.getClassReference().getName(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PassthroughDataflowClassVisitor实现中，重点在于visitMethod方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不是目标观察的method需要跳过，上一步得到的method都是有调用关系的method才需要数据流分析</span><br><span class="line">if (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在上述构造PassthroughDataflowClassVisitor时，最后一个参数传入的便是需要观察的方法，因此，在ASM每观察到一个方法都会执行visitMethod的时候，通过此处重新判断是否我们关心的方法，只有我们关心的方法，最终才通过下一步构建PassthroughDataflowMethodVisitor对其进行方法级别的观察</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对method进行观察</span><br><span class="line">MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">passthroughDataflowMethodVisitor = new PassthroughDataflowMethodVisitor(</span><br><span class="line">        classMap, inheritanceMap, this.passthroughDataflow, serializableDecider,</span><br><span class="line">        api, mv, this.name, access, name, desc, signature, exceptions);</span><br></pre></td></tr></table></figure>
<p>继续跟进PassthroughDataflowMethodVisitor，可以看到，它继承了TaintTrackingMethodVisitor，并有以下几个方法的实现：</p>
<ol>
<li>visitCode：在进入方法的第一时间，ASM会先调用这个方法</li>
<li>visitInsn：在方法体重，每一个字节码操作指令的执行，ASM都会调用这个方法</li>
<li>visitFieldInsn：对于字段的调用，ASM都会调用这个方法</li>
<li>visitMethodInsn：方法体内，一旦调用了其他方法，都会触发这个方法的调用</li>
</ol>
<p>在展示这四个方法的具体代码前，我还要说一下其父类中的一个方法：visitVarInsn，这个方法，会在方法体内字节码操作变量时，会被调用</p>
<p>为了实现类似污点分析，去分析参数对方法的污染，其模仿了jvm，实现了两个个集合，分别是本地变量表和操作数栈，通过其，实现具体的污点分析，那么具体是怎么进行的呢？</p>
<p>在分析前，我继续贴一个代码例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  public String main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method1(args);</span><br><span class="line">    return new B().method2(cmd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">  public String method2(String param) &#123;</span><br><span class="line">    return new C().method3(param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C &#123;</span><br><span class="line">  public String method3(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过逆拓扑排序后得到的列表为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.method1</span><br><span class="line">C.method3</span><br><span class="line">B.method2</span><br><span class="line">main</span><br></pre></td></tr></table></figure>
<p>那么，分析也是根据这个顺序进行</p>
<ul>
<li>A.method1：<br>第一步，ASM对A.method1进行观察，也就是PassthroughDataflowMethodVisitor进行观察，那么，在其方法被执行开始的时候，会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在这一步的代码中，我们可以看到，会对方法是否是static方法等进行判断，接着做了一个操作，就是把入参放到了本地变量表中来，为什么要这样做呢？我们可以想象一下，一个方法内部，能用到的数据要不就是本地变量表的数据，要不就是通过字段调用的数据，那么，在分析调用其他方法，或者对返回值是否会被入参污染时的数据流动，都跟它紧密关联，为什么这样说？根据jvm字节码的操作，在调用方法前，肯定需要对相关参数进行入栈，那入栈的数据从哪里来，必然就是本地变量表或者其他字段。那么在形成这样的一个本地变量表之后，就能标识一个方法内部的数据流动，并最终确定污染结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitCode() &#123;</span><br><span class="line">    super.visitCode();</span><br><span class="line"></span><br><span class="line">    int localIndex = 0;</span><br><span class="line">    int argIndex = 0;</span><br><span class="line">    if ((this.access &amp; Opcodes.ACC_STATIC) == 0) &#123;</span><br><span class="line">        //非静态方法，第一个局部变量应该为对象实例this</span><br><span class="line">        //添加到本地变量表集合</span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += 1;</span><br><span class="line">        argIndex += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        //判断参数类型，得出变量占用空间大小，然后存储</span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected void setLocalTaint(int index, T ... possibleValues) &#123;</span><br><span class="line">    Set&lt;T&gt; values = new HashSet&lt;T&gt;();</span><br><span class="line">    for (T value : possibleValues) &#123;</span><br><span class="line">        values.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    savedVariableState.localVars.set(index, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，在入参进入本地变量表之后，会执行return这个代码，并把param这个参数返回，在这个指令执行的时候会触发visitVarInsn方法，那么在进行return操作前，首先，会对其参数param进行入栈，因为param是引用类型，那么操作代码就是Opcodes.ALOAD，可以看到，代码中，从本地变量表获取了变量索引，并放入到操作数栈中来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitVarInsn(int opcode, int var) &#123;</span><br><span class="line">    // Extend local variable state to make sure we include the variable index</span><br><span class="line">    for (int i = savedVariableState.localVars.size(); i &lt;= var; i++) &#123;</span><br><span class="line">        savedVariableState.localVars.add(new HashSet&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;T&gt; saved0;</span><br><span class="line">    switch(opcode) &#123;</span><br><span class="line">        case Opcodes.ILOAD:</span><br><span class="line">        case Opcodes.FLOAD:</span><br><span class="line">            push();</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.LLOAD:</span><br><span class="line">        case Opcodes.DLOAD:</span><br><span class="line">            push();</span><br><span class="line">            push();</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ALOAD:</span><br><span class="line">            push(savedVariableState.localVars.get(var));</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ISTORE:</span><br><span class="line">        case Opcodes.FSTORE:</span><br><span class="line">            pop();</span><br><span class="line">            savedVariableState.localVars.set(var, new HashSet&lt;T&gt;());</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.DSTORE:</span><br><span class="line">        case Opcodes.LSTORE:</span><br><span class="line">            pop();</span><br><span class="line">            pop();</span><br><span class="line">            savedVariableState.localVars.set(var, new HashSet&lt;T&gt;());</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ASTORE:</span><br><span class="line">            saved0 = pop();</span><br><span class="line">            savedVariableState.localVars.set(var, saved0);</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.RET:</span><br><span class="line">            // No effect on stack</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitVarInsn(opcode, var);</span><br><span class="line"></span><br><span class="line">    sanityCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，执行return指令，也就触发visitInsn这个方法，因为返回的是引用类型，那么相应的指令就是Opcodes.ARETURN，可以看到，在这个case中，会从栈顶，获取刚刚入栈（第二步中visitVarInsn从本地变量表获取的参数索引）的参数索引，并存储到returnTaint中，因此，即表示A.method1这个方法的调用，参数索引为1的参数param会污染返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitInsn(int opcode) &#123;</span><br><span class="line">    switch(opcode) &#123;</span><br><span class="line">        case Opcodes.IRETURN://从当前方法返回int</span><br><span class="line">        case Opcodes.FRETURN://从当前方法返回float</span><br><span class="line">        case Opcodes.ARETURN://从当前方法返回对象引用</span><br><span class="line">            returnTaint.addAll(getStackTaint(0));//栈空间从内存高位到低位分配空间</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.LRETURN://从当前方法返回long</span><br><span class="line">        case Opcodes.DRETURN://从当前方法返回double</span><br><span class="line">            returnTaint.addAll(getStackTaint(1));</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.RETURN://从当前方法返回void</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步，经过return之后，该方法的观察也就结束了，那么，回到gadgetinspector.PassthroughDiscovery#calculatePassthroughDataflow中，对于刚刚放到returnTaint污点分析结果，也会在其方法中，缓存到passthroughDataflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassReader cr = new ClassReader(inputStream);</span><br><span class="line">try &#123;</span><br><span class="line">    PassthroughDataflowClassVisitor cv = new PassthroughDataflowClassVisitor(classMap, inheritanceMap,</span><br><span class="line">            passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">    passthroughDataflow.put(method, cv.getReturnTaint());//缓存方法返回值与哪个参数有关系</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(&quot;Exception analyzing &quot; + method.getClassReference().getName(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>C.method3：该方法和A.method1的污点分析流程是一样的</p>
</li>
<li><p>B.method2：这个方法和前面连个都不一样，它内部调用了C.method3方法，因此，污点分析时，具体的细节就又不一样了</p>
</li>
</ul>
<p>第一步，在其方法被执行开始的时候，同样会触发PassthroughDataflowMethodVisitor.visitCode方法的调用，在其中，也是做了相应的操作，把入参存到了本地变量表中来</p>
<p>第二步，因为方法内部即将调用C.method3，那么ASM调用visitVarInsn方法，对其参数param进行入栈，因为param是引用类型，那么操作代码就是Opcodes.ALOAD，因此，从第一步保存的本地变量表中获取变量入栈</p>
<p>第三步，方法内部调用了C.method3，那么，ASM就会触发visitMethodInsn方法的执行，在这一步，会先对被调用方法的入参进行处理，并把被调用方法的实例放到argTypes的第一个索引位置，后面依次放置其他参数，接着计算返回值大小。然后，因为方法调用，第二步已经把参数入栈了，而这些参数都是从本地变量表获取的，那么，可以从栈顶取到相关参数，并认为这些参数是可被控制，也就是被当前调用者caller方法污染的，最后，也就是最重点的一步，从passthroughDataflow中获取了被调用方法的参数污染结果，也就是C.method3方法被分析时候，return存储的数据，所以，这里就印证了前面为什么要使用逆拓扑排序，因为如果不这样做的话，C.method3可能在B.method2后被分析，那么，缓存就不可能存在污点分析的结果，那么就没办法对B.method2进行正确的污点分析。接着就是对从缓存取出的污染结果和入参对比，取出相应索引的污点参数，放入到resultTaint中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">    //获取method参数类型</span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">    if (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        //如果执行的非静态方法，则把数组第一个元素类型设置为该实例对象的类型，类比局部变量表</span><br><span class="line">        Type[] extendedArgTypes = new Type[argTypes.length+1];</span><br><span class="line">        System.arraycopy(argTypes, 0, extendedArgTypes, 1, argTypes.length);</span><br><span class="line">        extendedArgTypes[0] = Type.getObjectType(owner);</span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取返回值类型大小</span><br><span class="line">    int retSize = Type.getReturnType(desc).getSize();</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; resultTaint;</span><br><span class="line">    switch (opcode) &#123;</span><br><span class="line">        case Opcodes.INVOKESTATIC://调用静态方法</span><br><span class="line">        case Opcodes.INVOKEVIRTUAL://调用实例方法</span><br><span class="line">        case Opcodes.INVOKESPECIAL://调用超类构造方法，实例初始化方法，私有方法</span><br><span class="line">        case Opcodes.INVOKEINTERFACE://调用接口方法</span><br><span class="line">            //todo 1 构造污染参数集合，方法调用前先把操作数入栈</span><br><span class="line">            final List&lt;Set&lt;Integer&gt;&gt; argTaint = new ArrayList&lt;Set&lt;Integer&gt;&gt;(argTypes.length);</span><br><span class="line">            for (int i = 0; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                argTaint.add(null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int stackIndex = 0;</span><br><span class="line">            for (int i = 0; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                Type argType = argTypes[i];</span><br><span class="line">                if (argType.getSize() &gt; 0) &#123;</span><br><span class="line">                    //根据参数类型大小，从栈底获取入参，参数入栈是从右到左的</span><br><span class="line">                    argTaint.set(argTypes.length - 1 - i, getStackTaint(stackIndex + argType.getSize() - 1));</span><br><span class="line">                &#125;</span><br><span class="line">                stackIndex += argType.getSize();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //todo 2 构造方法的调用，意味参数0可以污染返回值</span><br><span class="line">            if (name.equals(&quot;&lt;init&gt;&quot;)) &#123;</span><br><span class="line">                // Pass result taint through to original taint set; the initialized object is directly tainted by</span><br><span class="line">                // parameters</span><br><span class="line">                resultTaint = argTaint.get(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resultTaint = new HashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //todo 3 前面已做逆拓扑，调用链最末端最先被visit，因此，调用到的方法必然已被visit分析过</span><br><span class="line">            Set&lt;Integer&gt; passthrough = passthroughDataflow.get(new MethodReference.Handle(new ClassReference.Handle(owner), name, desc));</span><br><span class="line">            if (passthrough != null) &#123;</span><br><span class="line">                for (Integer passthroughDataflowArg : passthrough) &#123;</span><br><span class="line">                    //判断是否和同一方法体内的其它方法返回值关联，有关联则添加到栈底，等待执行return时保存</span><br><span class="line">                    resultTaint.addAll(argTaint.get(passthroughDataflowArg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">    if (retSize &gt; 0) &#123;</span><br><span class="line">        getStackTaint(retSize-1).addAll(resultTaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步，接着执行return，跟前面一样，保存到passthroughDataflow</p>
<ul>
<li>main：最后需要分析的是main方法的入参args是否会污染到其返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method1(args);</span><br><span class="line">    return new B().method2(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面A.method1、B.method2、C.method3的参数污染分析结果，很明显在观察main方法的时候</p>
<p>第一步，执行visitCode存储入参到本地变量表</p>
<p>第二步，执行visitVarInsn参数入栈</p>
<p>第三步，执行visitMethodInsn调用A.method1，A.method1被污染的返回结果，也就是参数索引会被放在栈顶</p>
<p>第四步，执行visitVarInsn把放在栈顶的污染参数索引，放入到本地变量表</p>
<p>第五步，执行visitVarInsn参数入</p>
<p>第六步，执行visitMethodInsn调用B.method2，被污染的返回结果会被放在栈顶</p>
<p>第七步，执行visitInsn，返回栈顶数据，缓存到passthroughDataflow，也就是main方法的污点分析结果</p>
<p>到此，ASM实现方法入参污染返回值的分析就到此为止了。</p>
<p>接下来，passthroughDiscovery.save方法就被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void save() throws IOException &#123;</span><br><span class="line">    if (passthroughDataflow == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Save called before discover()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataLoader.saveData(Paths.get(&quot;passthrough.dat&quot;), new PassThroughFactory(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是通过DataLoader.saveData把结果一行一行的保存到passthrough.dat文件中，而每行数据的序列化，是通过PassThroughFactory实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static class PassThroughFactory implements DataFactory&lt;Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; entry) &#123;</span><br><span class="line">        if (entry.getValue().size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String[] fields = new String[4];</span><br><span class="line">        fields[0] = entry.getKey().getClassReference().getName();</span><br><span class="line">        fields[1] = entry.getKey().getName();</span><br><span class="line">        fields[2] = entry.getKey().getDesc();</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (Integer arg : entry.getValue()) &#123;</span><br><span class="line">            sb.append(Integer.toString(arg));</span><br><span class="line">            sb.append(&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        fields[3] = sb.toString();</span><br><span class="line"></span><br><span class="line">        return fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，这一阶段分析保存下来passthrough.dat文件的数据格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述 能污染返回值的参数索引1,能污染返回值的参数索引2,能污染返回值的参数索引3...</span><br></pre></td></tr></table></figure>
<h3 id="0x05-方法调用关联-CallGraphDiscovery"><a href="#0x05-方法调用关联-CallGraphDiscovery" class="headerlink" title="0x05 方法调用关联-CallGraphDiscovery"></a>0x05 方法调用关联-CallGraphDiscovery</h3><p>在这一阶段，会进行对方法调用关联的分析，也就是方法调用者caller和方法被调用者target直接的参数关联</p>
<p>举个例子描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  public void main(String args) throws IOException &#123;</span><br><span class="line">    String cmd = new A().method1(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param) &#123;</span><br><span class="line">    return param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在经过这个阶段，能得到的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1</span><br></pre></td></tr></table></figure>
<p>跟回代码，gadgetinspector.CallGraphDiscovery#discover：</p>
<p>加载了前面几个阶段分析处理的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加载所有方法信息</span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">//加载所有类信息</span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">//加载所有父子类、超类、实现类关系</span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">//加载所有方法参数和返回值的污染关联</span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br></pre></td></tr></table></figure></p>
<p>接着遍历每一个class，并对其使用ASM进行观察</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SerializableDecider serializableDecider = config.getSerializableDecider(methodMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">    try (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">        ClassReader cr = new ClassReader(in);</span><br><span class="line">        try &#123;</span><br><span class="line">            cr.accept(new ModelGeneratorClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6),</span><br><span class="line">                    ClassReader.EXPAND_FRAMES);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.error(&quot;Error analyzing: &quot; + classResource.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModelGeneratorClassVisitor的实现没什么重点的逻辑，主要就是对每一个方法都进行了ASM的观察</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private class ModelGeneratorClassVisitor extends ClassVisitor &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;ClassReference.Handle, ClassReference&gt; classMap;</span><br><span class="line">    private final InheritanceMap inheritanceMap;</span><br><span class="line">    private final Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;</span><br><span class="line">    private final SerializableDecider serializableDecider;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc,</span><br><span class="line">                                     String signature, String[] exceptions) &#123;</span><br><span class="line">        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        ModelGeneratorMethodVisitor modelGeneratorMethodVisitor = new ModelGeneratorMethodVisitor(classMap,</span><br><span class="line">                inheritanceMap, passthroughDataflow, serializableDecider, api, mv, this.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        return new JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModelGeneratorMethodVisitor的实现，是这一步的重点逻辑所在，因为单单文字描述可能理解不太清楚，我这边继续以一个例子进行讲解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public void main(String args) throws IOException &#123;</span><br><span class="line">    new A().method1(args, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param, String param2) &#123;</span><br><span class="line">    return param + param2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上述例子中，Main的main方法中，调用了A.main1方法，并且入参是main的参数args以及Main的字段name</p>
<p>ASM的实现流程：</p>
<ul>
<li>在Main.main方法体被观察到的第一时间，ASM会调用ModelGeneratorMethodVisitor.visitCode，在这个方法中，根据参数的数量，一一形成名称arg0、arg1…，然后放入到本地变量表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitCode() &#123;</span><br><span class="line">    super.visitCode();</span><br><span class="line"></span><br><span class="line">    int localIndex = 0;</span><br><span class="line">    int argIndex = 0;</span><br><span class="line">    //使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span><br><span class="line">    if ((this.access &amp; Opcodes.ACC_STATIC) == 0) &#123;</span><br><span class="line">        setLocalTaint(localIndex, &quot;arg&quot; + argIndex);</span><br><span class="line">        localIndex += 1;</span><br><span class="line">        argIndex += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        setLocalTaint(localIndex, &quot;arg&quot; + argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接着，因为即将要调用A.method1，ASM会调用visitVarInsn，把刚刚放入到本地变量表的arg0入栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitVarInsn(int opcode, int var) &#123;</span><br><span class="line">    // Extend local variable state to make sure we include the variable index</span><br><span class="line">    for (int i = savedVariableState.localVars.size(); i &lt;= var; i++) &#123;</span><br><span class="line">        savedVariableState.localVars.add(new HashSet&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;T&gt; saved0;</span><br><span class="line">    switch(opcode) &#123;</span><br><span class="line">        case Opcodes.ILOAD:</span><br><span class="line">        case Opcodes.FLOAD:</span><br><span class="line">            push();</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.LLOAD:</span><br><span class="line">        case Opcodes.DLOAD:</span><br><span class="line">            push();</span><br><span class="line">            push();</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ALOAD:</span><br><span class="line">            push(savedVariableState.localVars.get(var));</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ISTORE:</span><br><span class="line">        case Opcodes.FSTORE:</span><br><span class="line">            pop();</span><br><span class="line">            savedVariableState.localVars.set(var, new HashSet&lt;T&gt;());</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.DSTORE:</span><br><span class="line">        case Opcodes.LSTORE:</span><br><span class="line">            pop();</span><br><span class="line">            pop();</span><br><span class="line">            savedVariableState.localVars.set(var, new HashSet&lt;T&gt;());</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.ASTORE:</span><br><span class="line">            saved0 = pop();</span><br><span class="line">            savedVariableState.localVars.set(var, saved0);</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.RET:</span><br><span class="line">            // No effect on stack</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitVarInsn(opcode, var);</span><br><span class="line"></span><br><span class="line">    sanityCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后，ASM调用visitVarInsn把当前实例对应的参数入栈，上一步visitCode已经把实例命名为arg0存在本地变量表中，因此入栈的参数名称为arg0，截止调用visitFieldInsn获取字段name，并命名为arg0.name入栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitFieldInsn(int opcode, String owner, String name, String desc) &#123;</span><br><span class="line"></span><br><span class="line">    switch (opcode) &#123;</span><br><span class="line">        case Opcodes.GETSTATIC:</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.PUTSTATIC:</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.GETFIELD://入操作栈</span><br><span class="line">            Type type = Type.getType(desc);</span><br><span class="line">            if (type.getSize() == 1) &#123;</span><br><span class="line">                Boolean isTransient = null;</span><br><span class="line"></span><br><span class="line">                // If a field type could not possibly be serialized, it&apos;s effectively transient</span><br><span class="line">                if (!couldBeSerialized(serializableDecider, inheritanceMap, new ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ClassReference clazz = classMap.get(new ClassReference.Handle(owner));</span><br><span class="line">                    while (clazz != null) &#123;</span><br><span class="line">                        for (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            if (member.getName().equals(name)) &#123;</span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != 0;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (isTransient != null) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clazz = classMap.get(new ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;String&gt; newTaint = new HashSet&lt;&gt;();</span><br><span class="line">                if (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    for (String s : getStackTaint(0)) &#123;</span><br><span class="line">                        newTaint.add(s + &quot;.&quot; + name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                super.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                //在调用方法前，都会先入栈，作为参数</span><br><span class="line">                setStackTaint(0, newTaint);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case Opcodes.PUTFIELD:</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后ASM调用visitMethodInsn，因为Main.main调用了A.method1，在这里个环境，清楚的用代码解释了为什么前面需要把参数命名为arg0、arg1、arg0.name这样，因为需要通过这样的一个字符串名称，和被调用方法的入参进行关联，并最终形成调用者和被调用者直接的参数关联</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">    //获取被调用method的参数和类型，非静态方法需要把实例类型放在第一个元素</span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">    if (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        Type[] extendedArgTypes = new Type[argTypes.length+1];</span><br><span class="line">        System.arraycopy(argTypes, 0, extendedArgTypes, 1, argTypes.length);</span><br><span class="line">        extendedArgTypes[0] = Type.getObjectType(owner);</span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (opcode) &#123;</span><br><span class="line">        case Opcodes.INVOKESTATIC:</span><br><span class="line">        case Opcodes.INVOKEVIRTUAL:</span><br><span class="line">        case Opcodes.INVOKESPECIAL:</span><br><span class="line">        case Opcodes.INVOKEINTERFACE:</span><br><span class="line">            int stackIndex = 0;</span><br><span class="line">            for (int i = 0; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                //最右边的参数，就是最后入栈，即在栈顶</span><br><span class="line">                int argIndex = argTypes.length-1-i;</span><br><span class="line">                Type type = argTypes[argIndex];</span><br><span class="line">                //操作数栈出栈，调用方法前，参数都已入栈</span><br><span class="line">                Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                if (taint.size() &gt; 0) &#123;</span><br><span class="line">                    for (String argSrc : taint) &#123;</span><br><span class="line">                        //取出出栈的参数，判断是否为当前方法的入参，arg前缀</span><br><span class="line">                        if (!argSrc.substring(0, 3).equals(&quot;arg&quot;)) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Invalid taint arg: &quot; + argSrc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        int dotIndex = argSrc.indexOf(&apos;.&apos;);</span><br><span class="line">                        int srcArgIndex;</span><br><span class="line">                        String srcArgPath;</span><br><span class="line">                        if (dotIndex == -1) &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(3));</span><br><span class="line">                            srcArgPath = null;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(3, dotIndex));</span><br><span class="line">                            srcArgPath = argSrc.substring(dotIndex+1);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //记录参数流动关系</span><br><span class="line">                        //argIndex：当前方法参数索引，srcArgIndex：对应上一级方法的参数索引</span><br><span class="line">                        discoveredCalls.add(new GraphCall(</span><br><span class="line">                                new MethodReference.Handle(new ClassReference.Handle(this.owner), this.name, this.desc),</span><br><span class="line">                                new MethodReference.Handle(new ClassReference.Handle(owner), name, desc),</span><br><span class="line">                                srcArgIndex,</span><br><span class="line">                                srcArgPath,</span><br><span class="line">                                argIndex));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stackIndex += type.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，gadgetinspector.CallGraphDiscovery#discover方法就结束了，然后执行gadgetinspector.CallGraphDiscovery#save对调用者-被调用者参数关系数据进行保存到callgraph.dat文件，其中数据的序列化输出格式，由GraphCall.Factory实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static class Factory implements DataFactory&lt;GraphCall&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(GraphCall obj) &#123;</span><br><span class="line">        return new String[]&#123;</span><br><span class="line">                obj.callerMethod.getClassReference().getName(), obj.callerMethod.getName(), obj.callerMethod.getDesc(),</span><br><span class="line">                obj.targetMethod.getClassReference().getName(), obj.targetMethod.getName(), obj.targetMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.callerArgIndex),</span><br><span class="line">                obj.callerArgPath,</span><br><span class="line">                Integer.toString(obj.targetArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者类名 调用者方法caller 调用者方法描述 被调用者类名 被调用者方法target 被调用者方法描述 调用者方法参数索引 调用者字段名 被调用者方法参数索引</span><br><span class="line">Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1</span><br></pre></td></tr></table></figure>
<h3 id="0x06-利用链入口搜索-SourceDiscovery"><a href="#0x06-利用链入口搜索-SourceDiscovery" class="headerlink" title="0x06 利用链入口搜索-SourceDiscovery"></a>0x06 利用链入口搜索-SourceDiscovery</h3><p>在这一个阶段中，会扫描所有的class，把符合，也就是可被反序列化并且可以在反序列化执行的方法，全部查找出来，因为没有这样的入口，就算存在执行链，也没办法通过反序列化的时候进行触发。</p>
<p>因为入口的触发，不同的反序列化方式会存在不同是实现，因此，在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，我这里主要以jackson的SourceDiscovery实现开始分析。</p>
<p>先看SourceDiscovery抽象类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SourceDiscovery &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;Source&gt; discoveredSources = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    protected final void addDiscoveredSource(Source source) &#123;</span><br><span class="line">        discoveredSources.add(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void discover() throws IOException &#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        discover(classMap, methodMap, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span><br><span class="line">                         InheritanceMap inheritanceMap);</span><br><span class="line"></span><br><span class="line">    public void save() throws IOException &#123;</span><br><span class="line">        DataLoader.saveData(Paths.get(&quot;sources.dat&quot;), new Source.Factory(), discoveredSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它的discover实现中，加载了所以的类、方法、继承实现关系数据，接着调用抽象方法discover，然后，我们跟进jackson的具体实现中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class JacksonSourceDiscovery extends SourceDiscovery &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span><br><span class="line">                         InheritanceMap inheritanceMap) &#123;</span><br><span class="line"></span><br><span class="line">        final JacksonSerializableDecider serializableDecider = new JacksonSerializableDecider(methodMap);</span><br><span class="line"></span><br><span class="line">        for (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            if (serializableDecider.apply(method.getClassReference())) &#123;</span><br><span class="line">                if (method.getName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; method.getDesc().equals(&quot;()V&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">                if (method.getName().startsWith(&quot;get&quot;) &amp;&amp; method.getDesc().startsWith(&quot;()&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">                if (method.getName().startsWith(&quot;set&quot;) &amp;&amp; method.getDesc().matches(&quot;\\(L[^;]*;\\)V&quot;)) &#123;</span><br><span class="line">                    addDiscoveredSource(new Source(method, 0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，实现非常之简单，只是判断了方法：</p>
<ol>
<li>是否无参构造方法</li>
<li>是否getter方法</li>
<li>是否setter方法</li>
</ol>
<p>为什么对于source会做这样的判断？因为对于jackson的反序列化，在其反序列化时，必须通过无参构造方法反序列化（没有则会反序列化失败），并且会根据一定情况调用其反序列化对象的getter、setter方法</p>
<p>在扫描所有的方法后，具备条件的method都会被添加到gadgetinspector.SourceDiscovery#discoveredSources中，并最后通过gadgetinspector.SourceDiscovery#save保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void save() throws IOException &#123;</span><br><span class="line">    DataLoader.saveData(Paths.get(&quot;sources.dat&quot;), new Source.Factory(), discoveredSources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存数据的序列化实现由Source.Factory实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static class Factory implements DataFactory&lt;Source&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] serialize(Source obj) &#123;</span><br><span class="line">        return new String[]&#123;</span><br><span class="line">                obj.sourceMethod.getClassReference().getName(), obj.sourceMethod.getName(), obj.sourceMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.taintedArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出到sources.dat文件的数据形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述 污染参数索引</span><br></pre></td></tr></table></figure>
<h3 id="0x07-最终挖掘阶段-GadgetChainDiscovery"><a href="#0x07-最终挖掘阶段-GadgetChainDiscovery" class="headerlink" title="0x07 最终挖掘阶段-GadgetChainDiscovery"></a>0x07 最终挖掘阶段-GadgetChainDiscovery</h3><p>这个阶段，是gadgetinspector自动化挖掘gadget chain的最终阶段，该阶段利用前面获取到的所有数据，从source到slink进行整合分析，最终判断slink，确定是否有效的gadget chain。</p>
<p>分析gadgetinspector.GadgetChainDiscovery#discover代码：</p>
<p>加载所有的方法数据以及继承实现关系数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br></pre></td></tr></table></figure></p>
<h4 id="重写方法的扫描"><a href="#重写方法的扫描" class="headerlink" title="重写方法的扫描"></a>重写方法的扫描</h4><p>获取方法的所有实现，这是什么意思呢？因为java的继承特性，对于一个父类，它的方法实现，可以通过子孙类进行重写覆盖，为什么要这样做呢？因为多态特性，实现类只有运行时可确定，因此，需要对其所有重写实现都形成分析链，就能确保在非运行时，做到gadget chain的挖掘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);</span><br></pre></td></tr></table></figure></p>
<p>分析InheritanceDeriver.getAllMethodImplementations代码：</p>
<ol>
<li>获取类-&gt;方法集</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> //遍历整合，得到每个类的所有方法实现，形成 类-&gt;实现的方法集 的映射</span><br><span class="line">Map&lt;ClassReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodsByClass = new HashMap&lt;&gt;();</span><br><span class="line">for (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">    ClassReference.Handle classReference = method.getClassReference();</span><br><span class="line">    if (!methodsByClass.containsKey(classReference)) &#123;</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; methods = new HashSet&lt;&gt;();</span><br><span class="line">        methods.add(method);</span><br><span class="line">        methodsByClass.put(classReference, methods);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        methodsByClass.get(classReference).add(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>获取父类-&gt;子孙类集</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//遍历继承关系数据，形成 父类-&gt;子孙类集 的映射</span><br><span class="line">Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap = new HashMap&lt;&gt;();</span><br><span class="line">for (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">    for (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">        if (!subClassMap.containsKey(parent)) &#123;</span><br><span class="line">            Set&lt;ClassReference.Handle&gt; subClasses = new HashSet&lt;&gt;();</span><br><span class="line">            subClasses.add(entry.getKey());</span><br><span class="line">            subClassMap.put(parent, subClasses);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subClassMap.get(parent).add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>遍历每个方法，并通过查询方法类的子孙类的方法实现，确定重写方法，最后整合成 方法-&gt;重写的方法集 的映射集合，静态方法跳过，因为静态方法是不可被重写的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = new HashMap&lt;&gt;();</span><br><span class="line">for (MethodReference method : methodMap.values()) &#123;</span><br><span class="line">    // Static methods cannot be overriden</span><br><span class="line">    if (method.isStatic()) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; overridingMethods = new HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;ClassReference.Handle&gt; subClasses = subClassMap.get(method.getClassReference());</span><br><span class="line">    if (subClasses != null) &#123;</span><br><span class="line">        for (ClassReference.Handle subClass : subClasses) &#123;</span><br><span class="line">            // This class extends ours; see if it has a matching method</span><br><span class="line">            Set&lt;MethodReference.Handle&gt; subClassMethods = methodsByClass.get(subClass);</span><br><span class="line">            if (subClassMethods != null) &#123;</span><br><span class="line">                for (MethodReference.Handle subClassMethod : subClassMethods) &#123;</span><br><span class="line">                    if (subClassMethod.getName().equals(method.getName()) &amp;&amp; subClassMethod.getDesc().equals(method.getDesc())) &#123;</span><br><span class="line">                        overridingMethods.add(subClassMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (overridingMethods.size() &gt; 0) &#123;</span><br><span class="line">        methodImplMap.put(method.getHandle(), overridingMethods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="保存方法重写数据"><a href="#保存方法重写数据" class="headerlink" title="保存方法重写数据"></a>保存方法重写数据</h4><p>回到gadgetinspector.GadgetChainDiscovery#discover中，接着，对扫描到的重写方法数据进行保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">try (Writer writer = Files.newBufferedWriter(Paths.get(&quot;methodimpl.dat&quot;))) &#123;</span><br><span class="line">    for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">        writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">        writer.write(&quot;\t&quot;);</span><br><span class="line">        writer.write(entry.getKey().getName());</span><br><span class="line">        writer.write(&quot;\t&quot;);</span><br><span class="line">        writer.write(entry.getKey().getDesc());</span><br><span class="line">        writer.write(&quot;\n&quot;);</span><br><span class="line">        for (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">            writer.write(&quot;\t&quot;);</span><br><span class="line">            writer.write(method.getClassReference().getName());</span><br><span class="line">            writer.write(&quot;\t&quot;);</span><br><span class="line">            writer.write(method.getName());</span><br><span class="line">            writer.write(&quot;\t&quot;);</span><br><span class="line">            writer.write(method.getDesc());</span><br><span class="line">            writer.write(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存的数据格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br><span class="line">类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br><span class="line">\t重写方法的类名 方法名 方法描述</span><br></pre></td></tr></table></figure>
<h4 id="整合方法调用关联数据"><a href="#整合方法调用关联数据" class="headerlink" title="整合方法调用关联数据"></a>整合方法调用关联数据</h4><p>在前面阶段中，扫描出来的方法调用参数关联数据，都是独立的，也就是说，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public void main(String args) throws IOException &#123;</span><br><span class="line">    new A().method1(args, name);</span><br><span class="line">    new A().method2(args, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  public String method1(String param, String param2) &#123;</span><br><span class="line">    return param + param2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String method2(String param, String param2) &#123;</span><br><span class="line">    return param + param2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>形成的方法调用参数关联数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1</span><br><span class="line">Main (Ljava/lang/String;)V main A method2 (Ljava/lang/String;)Ljava/lang/String; 1 1</span><br></pre></td></tr></table></figure>
<p>上面形成的数据是分为了两条独立的数据，在统一的分析中，不太利于分析，因此，对其进行了整合，因为对于这两条记录来说，其都是Main.main发起的方法调用</p>
<p>整合代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = new HashMap&lt;&gt;();</span><br><span class="line">for (GraphCall graphCall : DataLoader.loadData(Paths.get(&quot;callgraph.dat&quot;), new GraphCall.Factory())) &#123;</span><br><span class="line">    MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">    if (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">        Set&lt;GraphCall&gt; graphCalls = new HashSet&lt;&gt;();</span><br><span class="line">        graphCalls.add(graphCall);</span><br><span class="line">        graphCallMap.put(caller, graphCalls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        graphCallMap.get(caller).add(graphCall);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="gadget-chain的初始化"><a href="#gadget-chain的初始化" class="headerlink" title="gadget chain的初始化"></a>gadget chain的初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;GadgetChainLink&gt; exploredMethods = new HashSet&lt;&gt;();</span><br><span class="line">LinkedList&lt;GadgetChain&gt; methodsToExplore = new LinkedList&lt;&gt;();</span><br><span class="line">for (Source source : DataLoader.loadData(Paths.get(&quot;sources.dat&quot;), new Source.Factory())) &#123;</span><br><span class="line">    GadgetChainLink srcLink = new GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">    if (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    methodsToExplore.add(new GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">    exploredMethods.add(srcLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，加载了sources.dat文件的数据，这些数据我们前面分析过，都是利用链入口，在被反序列化的时候可被触发执行的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static class GadgetChainLink &#123;</span><br><span class="line">    private final MethodReference.Handle method;</span><br><span class="line">    private final int taintedArgIndex;</span><br><span class="line"></span><br><span class="line">    private GadgetChainLink(MethodReference.Handle method, int taintedArgIndex) &#123;</span><br><span class="line">        this.method = method;</span><br><span class="line">        this.taintedArgIndex = taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line"></span><br><span class="line">        GadgetChainLink that = (GadgetChainLink) o;</span><br><span class="line"></span><br><span class="line">        if (taintedArgIndex != that.taintedArgIndex) return false;</span><br><span class="line">        return method != null ? method.equals(that.method) : that.method == null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int result = method != null ? method.hashCode() : 0;</span><br><span class="line">        result = 31 * result + taintedArgIndex;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后形成gadget chain的初始化工作</p>
<h4 id="遍历初始化后的gadget-chain集合"><a href="#遍历初始化后的gadget-chain集合" class="headerlink" title="遍历初始化后的gadget chain集合"></a>遍历初始化后的gadget chain集合</h4><p>gadget chain取出，进行链可利用的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain chain = methodsToExplore.pop();</span><br></pre></td></tr></table></figure>
<p>获取链的最后一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GadgetChainLink lastLink = chain.links.get(chain.links.size()-1);</span><br></pre></td></tr></table></figure>
<p>获取最后一个方法调用到的所有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br></pre></td></tr></table></figure>
<p>遍历调用到的方法，若方法不能被污染传递，则跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">    if (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取被调用方法的所有重写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br></pre></td></tr></table></figure>
<p>遍历所有重写方法，并加入链的最后一节，若已存在的链，为了避免死循环，因此会跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">GadgetChainLink newLink = new GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">if (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br><span class="line">GadgetChain newChain = new GadgetChain(chain, newLink);</span><br></pre></td></tr></table></figure>
<p>判断是否到了slink，若已到，则表示这条链可用，并缓存到discoveredGadgets中，若还没到slink，则把newChain加到集合中，随着下一次循环到的时候，再次分析下一层的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">    discoveredGadgets.add(newChain);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    methodsToExplore.add(newChain);</span><br><span class="line">    exploredMethods.add(newLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slink的判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private boolean isSink(MethodReference.Handle method, int argIndex, InheritanceMap inheritanceMap) &#123;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/io/FileInputStream&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;&lt;init&gt;&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/io/FileOutputStream&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;&lt;init&gt;&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/nio/file/Files&quot;)</span><br><span class="line">        &amp;&amp; (method.getName().equals(&quot;newInputStream&quot;)</span><br><span class="line">            || method.getName().equals(&quot;newOutputStream&quot;)</span><br><span class="line">            || method.getName().equals(&quot;newBufferedReader&quot;)</span><br><span class="line">            || method.getName().equals(&quot;newBufferedWriter&quot;))) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/Runtime&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;exec&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;forName&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;getMethod&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    // If we can invoke an arbitrary method, that&apos;s probably interesting (though this doesn&apos;t assert that we</span><br><span class="line">    // can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span><br><span class="line">    // method is being invoked, we don&apos;t mark that as interesting.</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/reflect/Method&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;invoke&quot;) &amp;&amp; argIndex == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/net/URLClassLoader&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;newInstance&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/System&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;exit&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/Shutdown&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;exit&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/Runtime&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;exit&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/nio/file/Files&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;newOutputStream&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/lang/ProcessBuilder&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; argIndex &gt; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(&quot;java/lang/ClassLoader&quot;))</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;&lt;init&gt;&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;java/net/URL&quot;) &amp;&amp; method.getName().equals(&quot;openStream&quot;)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Some groovy-specific sinks</span><br><span class="line">    if (method.getClassReference().getName().equals(&quot;org/codehaus/groovy/runtime/InvokerHelper&quot;)</span><br><span class="line">            &amp;&amp; method.getName().equals(&quot;invokeMethod&quot;) &amp;&amp; argIndex == 1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(&quot;groovy/lang/MetaClass&quot;))</span><br><span class="line">            &amp;&amp; Arrays.asList(&quot;invokeMethod&quot;, &quot;invokeConstructor&quot;, &quot;invokeStaticMethod&quot;).contains(method.getName())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个gadgetinspector的源码浅析就结束，祝大家阅读愉快，新年将至，提前说声新年快乐！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/自动化工具/" rel="tag"># 自动化工具</a>
          
            <a href="/tags/gadgetinspector/" rel="tag"># gadgetinspector</a>
          
            <a href="/tags/java反序列化/" rel="tag"># java反序列化</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/12/Struts2 RCE漏洞分析系列 - 0x01基础篇/" rel="next" title="Struts2 RCE漏洞分析系列 - 0x01基础篇">
                <i class="fa fa-chevron-left"></i> Struts2 RCE漏洞分析系列 - 0x01基础篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/24/Spring-Data-Commons CVE-2018-1273 RCE漏洞分析/" rel="prev" title="Spring-Data-Commons CVE-2018-1273 RCE漏洞分析">
                Spring-Data-Commons CVE-2018-1273 RCE漏洞分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg" alt="threedr3am">
            
              <p class="site-author-name" itemprop="name">threedr3am</p>
              <p class="site-description motion-element" itemprop="description">菜到如此</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/threedr3am" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://driverxdw.github.io/" title="in0va'S(dw大鸽)" target="_blank">in0va'S(dw大鸽)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gengzongyuan.github.io/" title="大树先生(测试大牛)" target="_blank">大树先生(测试大牛)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://chensem.github.io/" title="chensem(逆向龙哥)" target="_blank">chensem(逆向龙哥)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://meizjm3i.github.io/" title="梅子酒" target="_blank">梅子酒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.orange.tw/" title="orange" target="_blank">orange</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-前言"><span class="nav-number">1.</span> <span class="nav-text">0x01 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02-GadgetInspector：入口代码的分析"><span class="nav-number">2.</span> <span class="nav-text">0x02 GadgetInspector：入口代码的分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03-MethodDiscovery"><span class="nav-number">3.</span> <span class="nav-text">0x03 MethodDiscovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04-方法入参和返回值污点分析-PassthroughDiscovery"><span class="nav-number">4.</span> <span class="nav-text">0x04 方法入参和返回值污点分析-PassthroughDiscovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x05-方法调用关联-CallGraphDiscovery"><span class="nav-number">5.</span> <span class="nav-text">0x05 方法调用关联-CallGraphDiscovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x06-利用链入口搜索-SourceDiscovery"><span class="nav-number">6.</span> <span class="nav-text">0x06 利用链入口搜索-SourceDiscovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x07-最终挖掘阶段-GadgetChainDiscovery"><span class="nav-number">7.</span> <span class="nav-text">0x07 最终挖掘阶段-GadgetChainDiscovery</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重写方法的扫描"><span class="nav-number">7.1.</span> <span class="nav-text">重写方法的扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保存方法重写数据"><span class="nav-number">7.2.</span> <span class="nav-text">保存方法重写数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整合方法调用关联数据"><span class="nav-number">7.3.</span> <span class="nav-text">整合方法调用关联数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gadget-chain的初始化"><span class="nav-number">7.4.</span> <span class="nav-text">gadget chain的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历初始化后的gadget-chain集合"><span class="nav-number">7.5.</span> <span class="nav-text">遍历初始化后的gadget chain集合</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">threedr3am</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
